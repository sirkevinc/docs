{"version":3,"file":"slate-react.es.js","sources":["../src/constants/event-handlers.js","../src/constants/data-attributes.js","../src/constants/selectors.js","../src/utils/offset-key.js","../src/components/leaf.js","../src/components/text.js","../src/components/void.js","../src/components/node.js","../src/utils/scroll-to-selection.js","../src/utils/remove-all-ranges.js","../src/components/content.js","../src/plugins/react/editor-props.js","../src/plugins/react/rendering.js","../src/plugins/react/commands.js","../src/plugins/react/queries.js","../src/plugins/android/fix-selection-in-zero-width-block.js","../src/utils/find-point.js","../src/utils/find-range.js","../src/utils/get-selection-from-dom.js","../src/plugins/android/is-input-data-enter.js","../src/plugins/android/is-input-data-last-char.js","../src/plugins/android/element-snapshot.js","../src/plugins/android/dom-snapshot.js","../src/plugins/android/executor.js","../src/plugins/android/index.js","../src/constants/transfer-types.js","../src/utils/find-dom-node.js","../src/utils/clone-fragment.js","../src/utils/get-event-transfer.js","../src/utils/set-event-transfer.js","../src/plugins/dom/after.js","../src/plugins/dom/before.js","../src/plugins/dom/index.js","../src/plugins/react/restore-dom.js","../src/plugins/debug/stringify-event.js","../src/plugins/debug/debug-events.js","../src/plugins/debug/debug-batch-events.js","../src/plugins/react/index.js","../src/components/editor.js","../src/utils/find-dom-point.js","../src/utils/find-dom-range.js","../src/utils/find-node.js","../src/utils/find-path.js","../src/utils/get-event-range.js","../src/index.js"],"sourcesContent":["/**\n * Event handlers used by Slate plugins.\n *\n * @type {Array}\n */\n\nconst EVENT_HANDLERS = [\n  'onBeforeInput',\n  'onBlur',\n  'onClick',\n  'onContextMenu',\n  'onCompositionEnd',\n  'onCompositionStart',\n  'onCopy',\n  'onCut',\n  'onDragEnd',\n  'onDragEnter',\n  'onDragExit',\n  'onDragLeave',\n  'onDragOver',\n  'onDragStart',\n  'onDrop',\n  'onInput',\n  'onFocus',\n  'onKeyDown',\n  'onKeyUp',\n  'onMouseDown',\n  'onMouseUp',\n  'onPaste',\n  'onSelect',\n]\n\n/**\n * Export.\n *\n * @type {Array}\n */\n\nexport default EVENT_HANDLERS\n","/**\n * DOM data attribute strings that refer to Slate concepts.\n *\n * @type {String}\n */\n\nexport default {\n  EDITOR: 'data-slate-editor',\n  FRAGMENT: 'data-slate-fragment',\n  KEY: 'data-key',\n  LEAF: 'data-slate-leaf',\n  LENGTH: 'data-slate-length',\n  OBJECT: 'data-slate-object',\n  OFFSET_KEY: 'data-offset-key',\n  SPACER: 'data-slate-spacer',\n  STRING: 'data-slate-string',\n  TEXT: 'data-slate-object',\n  VOID: 'data-slate-void',\n  ZERO_WIDTH: 'data-slate-zero-width',\n}\n","import DATA_ATTRS from './data-attributes'\n\n/**\n * DOM selector strings that refer to Slate concepts.\n *\n * @type {String}\n */\n\nexport default {\n  BLOCK: `[${DATA_ATTRS.OBJECT}=\"block\"]`,\n  EDITOR: `[${DATA_ATTRS.EDITOR}]`,\n  INLINE: `[${DATA_ATTRS.OBJECT}=\"inline\"]`,\n  KEY: `[${DATA_ATTRS.KEY}]`,\n  LEAF: `[${DATA_ATTRS.LEAF}]`,\n  OBJECT: `[${DATA_ATTRS.OBJECT}]`,\n  STRING: `[${DATA_ATTRS.STRING}]`,\n  TEXT: `[${DATA_ATTRS.OBJECT}=\"text\"]`,\n  VOID: `[${DATA_ATTRS.VOID}]`,\n  ZERO_WIDTH: `[${DATA_ATTRS.ZERO_WIDTH}]`,\n}\n","/**\n * Offset key parser regex.\n *\n * @type {RegExp}\n */\n\nconst PARSER = /^([\\w-]+)(?::(\\d+))?$/\n\n/**\n * Parse an offset key `string`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction parse(string) {\n  const matches = PARSER.exec(string)\n\n  if (!matches) {\n    throw new Error(`Invalid offset key string \"${string}\".`)\n  }\n\n  const [original, key, index] = matches // eslint-disable-line no-unused-vars\n  return {\n    key,\n    index: parseInt(index, 10),\n  }\n}\n\n/**\n * Stringify an offset key `object`.\n *\n * @param {Object} object\n *   @property {String} key\n *   @property {Number} index\n * @return {String}\n */\n\nfunction stringify(object) {\n  return `${object.key}:${object.index}`\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  parse,\n  stringify,\n}\n","import React from 'react'\nimport Types from 'prop-types'\nimport SlateTypes from 'slate-prop-types'\nimport ImmutableTypes from 'react-immutable-proptypes'\n\nimport OffsetKey from '../utils/offset-key'\nimport DATA_ATTRS from '../constants/data-attributes'\n\n/**\n * Leaf strings with text in them.\n *\n * @type {Component}\n */\n\nconst TextString = ({ text = '', isTrailing = false }) => {\n  return (\n    <span\n      {...{\n        [DATA_ATTRS.STRING]: true,\n      }}\n    >\n      {text}\n      {isTrailing ? '\\n' : null}\n    </span>\n  )\n}\n\n/**\n * Leaf strings without text, render as zero-width strings.\n *\n * @type {Component}\n */\n\nconst ZeroWidthString = ({ length = 0, isLineBreak = false }) => {\n  return (\n    <span\n      {...{\n        [DATA_ATTRS.ZERO_WIDTH]: isLineBreak ? 'n' : 'z',\n        [DATA_ATTRS.LENGTH]: length,\n      }}\n    >\n      {'\\uFEFF'}\n      {isLineBreak ? <br /> : null}\n    </span>\n  )\n}\n\n/**\n * Individual leaves in a text node with unique formatting.\n *\n * @type {Component}\n */\n\nconst Leaf = props => {\n  const {\n    marks,\n    annotations,\n    decorations,\n    node,\n    index,\n    offset,\n    text,\n    editor,\n    parent,\n    block,\n    leaves,\n  } = props\n\n  const offsetKey = OffsetKey.stringify({\n    key: node.key,\n    index,\n  })\n\n  let children\n\n  if (editor.query('isVoid', parent)) {\n    // COMPAT: Render text inside void nodes with a zero-width space.\n    // So the node can contain selection but the text is not visible.\n    children = <ZeroWidthString length={parent.text.length} />\n  } else if (\n    text === '' &&\n    parent.object === 'block' &&\n    parent.text === '' &&\n    parent.nodes.last() === node\n  ) {\n    // COMPAT: If this is the last text node in an empty block, render a zero-\n    // width space that will convert into a line break when copying and pasting\n    // to support expected plain text.\n    children = <ZeroWidthString isLineBreak />\n  } else if (text === '') {\n    // COMPAT: If the text is empty, it's because it's on the edge of an inline\n    // node, so we render a zero-width space so that the selection can be\n    // inserted next to it still.\n    children = <ZeroWidthString />\n  } else {\n    // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n    // so we need to add an extra trailing new lines to prevent that.\n    const lastText = block.getLastText()\n    const lastChar = text.charAt(text.length - 1)\n    const isLastText = node === lastText\n    const isLastLeaf = index === leaves.size - 1\n\n    if (isLastText && isLastLeaf && lastChar === '\\n') {\n      children = <TextString isTrailing text={text} />\n    } else {\n      children = <TextString text={text} />\n    }\n  }\n\n  const renderProps = {\n    editor,\n    marks,\n    annotations,\n    decorations,\n    node,\n    offset,\n    text,\n  }\n\n  // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n  for (const mark of marks) {\n    const ret = editor.run('renderMark', {\n      ...renderProps,\n      mark,\n      children,\n      attributes: {\n        [DATA_ATTRS.OBJECT]: 'mark',\n      },\n    })\n\n    if (ret) {\n      children = ret\n    }\n  }\n\n  for (const decoration of decorations) {\n    const ret = editor.run('renderDecoration', {\n      ...renderProps,\n      decoration,\n      children,\n      attributes: {\n        [DATA_ATTRS.OBJECT]: 'decoration',\n      },\n    })\n\n    if (ret) {\n      children = ret\n    }\n  }\n\n  for (const annotation of annotations) {\n    const ret = editor.run('renderAnnotation', {\n      ...renderProps,\n      annotation,\n      children,\n      attributes: {\n        [DATA_ATTRS.OBJECT]: 'annotation',\n      },\n    })\n\n    if (ret) {\n      children = ret\n    }\n  }\n\n  const attrs = {\n    [DATA_ATTRS.LEAF]: true,\n    [DATA_ATTRS.OFFSET_KEY]: offsetKey,\n  }\n\n  return <span {...attrs}>{children}</span>\n}\n\n/**\n * Prop types.\n *\n * @type {Object}\n */\n\nLeaf.propTypes = {\n  annotations: ImmutableTypes.list.isRequired,\n  block: SlateTypes.block.isRequired,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  index: Types.number.isRequired,\n  leaves: Types.object.isRequired,\n  marks: SlateTypes.marks.isRequired,\n  node: SlateTypes.node.isRequired,\n  offset: Types.number.isRequired,\n  parent: SlateTypes.node.isRequired,\n  text: Types.string.isRequired,\n}\n\n/**\n * A memoized version of `Leaf` that updates less frequently.\n *\n * @type {Component}\n */\n\nconst MemoizedLeaf = React.memo(Leaf, (prev, next) => {\n  return (\n    next.block === prev.block &&\n    next.index === prev.index &&\n    next.marks === prev.marks &&\n    next.parent === prev.parent &&\n    next.text === prev.text &&\n    next.annotations.equals(prev.annotations) &&\n    next.decorations.equals(prev.decorations)\n  )\n})\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default MemoizedLeaf\n","import ImmutableTypes from 'react-immutable-proptypes'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\n\nimport Leaf from './leaf'\nimport DATA_ATTRS from '../constants/data-attributes'\n\n/**\n * Text node.\n *\n * @type {Component}\n */\n\nconst Text = React.forwardRef((props, ref) => {\n  const { annotations, block, decorations, node, parent, editor, style } = props\n  const { key } = node\n  const leaves = node.getLeaves(annotations, decorations)\n  let at = 0\n\n  return (\n    <span\n      ref={ref}\n      style={style}\n      {...{\n        [DATA_ATTRS.OBJECT]: node.object,\n        [DATA_ATTRS.KEY]: key,\n      }}\n    >\n      {leaves.map((leaf, index) => {\n        const { text } = leaf\n        const offset = at\n        at += text.length\n\n        return (\n          <Leaf\n            key={`${node.key}-${index}`}\n            block={block}\n            editor={editor}\n            index={index}\n            annotations={leaf.annotations}\n            decorations={leaf.decorations}\n            marks={leaf.marks}\n            node={node}\n            offset={offset}\n            parent={parent}\n            leaves={leaves}\n            text={text}\n          />\n        )\n      })}\n    </span>\n  )\n})\n\n/**\n * Prop types.\n *\n * @type {Object}\n */\n\nText.propTypes = {\n  annotations: ImmutableTypes.map.isRequired,\n  block: SlateTypes.block,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node.isRequired,\n  style: Types.object,\n}\n\n/**\n * A memoized version of `Text` that updates less frequently.\n *\n * @type {Component}\n */\n\nconst MemoizedText = React.memo(Text, (prev, next) => {\n  return (\n    // PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n    next.node === prev.node &&\n    // If the node parent is a block node, and it was the last child of the\n    // block, re-render to cleanup extra `\\n`.\n    (next.parent.object === 'block' &&\n      prev.parent.nodes.last() === prev.node &&\n      next.parent.nodes.last() !== next.node) &&\n    // The formatting hasn't changed.\n    next.annotations.equals(prev.annotations) &&\n    next.decorations.equals(prev.decorations)\n  )\n})\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default MemoizedText\n","import Debug from 'debug'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\n\nimport Text from './text'\nimport DATA_ATTRS from '../constants/data-attributes'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:void')\n\n/**\n * Void.\n *\n * @type {Component}\n */\n\nclass Void extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    block: SlateTypes.block,\n    children: Types.any.isRequired,\n    editor: Types.object.isRequired,\n    node: SlateTypes.node.isRequired,\n    parent: SlateTypes.node.isRequired,\n    readOnly: Types.bool.isRequired,\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    const { node } = this.props\n    const { key, type } = node\n    const id = `${key} (${type})`\n    debug(message, `${id}`, ...args)\n  }\n\n  /**\n   * Render.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    const { props } = this\n    const { children, node, readOnly } = props\n    const Tag = node.object === 'block' ? 'div' : 'span'\n    const style = {\n      height: '0',\n      color: 'transparent',\n      outline: 'none',\n      position: 'absolute',\n    }\n\n    const spacerAttrs = {\n      [DATA_ATTRS.SPACER]: true,\n    }\n\n    const spacer = (\n      <Tag style={style} {...spacerAttrs}>\n        {this.renderText()}\n      </Tag>\n    )\n\n    const content = (\n      <Tag contentEditable={readOnly ? null : false}>{children}</Tag>\n    )\n\n    this.debug('render', { props })\n\n    const attrs = {\n      [DATA_ATTRS.VOID]: true,\n      [DATA_ATTRS.KEY]: node.key,\n    }\n\n    return (\n      <Tag\n        contentEditable={readOnly || node.object === 'block' ? null : false}\n        {...attrs}\n      >\n        {readOnly ? null : spacer}\n        {content}\n      </Tag>\n    )\n  }\n\n  /**\n   * Render the void node's text node, which will catch the cursor when it the\n   * void node is navigated to with the arrow keys.\n   *\n   * Having this text node there means the browser continues to manage the\n   * selection natively, so it keeps track of the right offset when moving\n   * across the block.\n   *\n   * @return {Element}\n   */\n\n  renderText = () => {\n    const {\n      annotations,\n      block,\n      decorations,\n      node,\n      readOnly,\n      editor,\n      textRef,\n    } = this.props\n    const child = node.getFirstText()\n    return (\n      <Text\n        ref={textRef}\n        annotations={annotations}\n        block={node.object === 'block' ? node : block}\n        decorations={decorations}\n        editor={editor}\n        key={child.key}\n        node={child}\n        parent={node}\n        readOnly={readOnly}\n      />\n    )\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Void\n","import Debug from 'debug'\nimport ImmutableTypes from 'react-immutable-proptypes'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport warning from 'tiny-warning'\nimport Types from 'prop-types'\nimport { PathUtils } from 'slate'\n\nimport Void from './void'\nimport Text from './text'\nimport DATA_ATTRS from '../constants/data-attributes'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:node')\n\n/**\n * Node.\n *\n * @type {Component}\n */\n\nclass Node extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    annotations: ImmutableTypes.map.isRequired,\n    block: SlateTypes.block,\n    decorations: ImmutableTypes.list.isRequired,\n    editor: Types.object.isRequired,\n    node: SlateTypes.node.isRequired,\n    parent: SlateTypes.node,\n    readOnly: Types.bool.isRequired,\n    selection: SlateTypes.selection,\n  }\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  tmp = {\n    nodeRefs: {},\n  }\n\n  /**\n   * A ref for the contenteditable DOM node.\n   *\n   * @type {Object}\n   */\n\n  ref = React.createRef()\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    const { node } = this.props\n    const { key, type } = node\n    debug(message, `${key} (${type})`, ...args)\n  }\n\n  /**\n   * Should the node update?\n   *\n   * @param {Object} nextProps\n   * @param {Object} value\n   * @return {Boolean}\n   */\n\n  shouldComponentUpdate(nextProps) {\n    const { props } = this\n    const { editor } = props\n    const shouldUpdate = editor.run(\n      'shouldNodeComponentUpdate',\n      props,\n      nextProps\n    )\n    const n = nextProps\n    const p = props\n\n    // If the `Component` has a custom logic to determine whether the component\n    // needs to be updated or not, return true if it returns true. If it returns\n    // false, we need to ignore it, because it shouldn't be allowed it.\n    if (shouldUpdate != null) {\n      warning(\n        false,\n        'As of slate-react@0.22 the `shouldNodeComponentUpdate` middleware is deprecated. You can pass specific values down the tree using React\\'s built-in \"context\" construct instead.'\n      )\n\n      if (shouldUpdate) {\n        return true\n      }\n\n      warning(\n        shouldUpdate !== false,\n        \"Returning false in `shouldNodeComponentUpdate` does not disable Slate's internal `shouldComponentUpdate` logic. If you want to prevent updates, use React's `shouldComponentUpdate` instead.\"\n      )\n    }\n\n    // If the `readOnly` status has changed, re-render in case there is any\n    // user-land logic that depends on it, like nested editable contents.\n    if (n.readOnly !== p.readOnly) {\n      return true\n    }\n\n    // If the node has changed, update. PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n    if (n.node !== p.node) {\n      return true\n    }\n\n    // If the selection value of the node or of some of its children has changed,\n    // re-render in case there is any user-land logic depends on it to render.\n    // if the node is selected update it, even if it was already selected: the\n    // selection value of some of its children could have been changed and they\n    // need to be rendered again.\n    if (\n      (!n.selection && p.selection) ||\n      (n.selection && !p.selection) ||\n      (n.selection && p.selection && !n.selection.equals(p.selection))\n    ) {\n      return true\n    }\n\n    // If the annotations have changed, update.\n    if (!n.annotations.equals(p.annotations)) {\n      return true\n    }\n\n    // If the decorations have changed, update.\n    if (!n.decorations.equals(p.decorations)) {\n      return true\n    }\n\n    // Otherwise, don't update.\n    return false\n  }\n\n  /**\n   * Render.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    this.debug('render', this)\n    const {\n      annotations,\n      block,\n      decorations,\n      editor,\n      node,\n      parent,\n      readOnly,\n      selection,\n    } = this.props\n\n    const newDecorations = node.getDecorations(editor)\n    const children = node.nodes.toArray().map((child, i) => {\n      const Component = child.object === 'text' ? Text : Node\n      const sel = selection && getRelativeRange(node, i, selection)\n\n      const decs = newDecorations\n        .map(d => getRelativeRange(node, i, d))\n        .filter(d => d)\n        .concat(decorations)\n\n      const anns = annotations\n        .map(a => getRelativeRange(node, i, a))\n        .filter(a => a)\n\n      return (\n        <Component\n          block={node.object === 'block' ? node : block}\n          editor={editor}\n          annotations={anns}\n          decorations={decs}\n          selection={sel}\n          key={child.key}\n          node={child}\n          parent={node}\n          readOnly={readOnly}\n          // COMPAT: We use this map of refs to lookup a DOM node down the\n          // tree of components by path.\n          ref={ref => {\n            if (ref) {\n              this.tmp.nodeRefs[i] = ref\n            } else {\n              delete this.tmp.nodeRefs[i]\n            }\n          }}\n        />\n      )\n    })\n\n    // Attributes that the developer must mix into the element in their\n    // custom node renderer component.\n    const attributes = {\n      [DATA_ATTRS.OBJECT]: node.object,\n      [DATA_ATTRS.KEY]: node.key,\n      ref: this.ref,\n    }\n\n    // If it's a block node with inline children, add the proper `dir` attribute\n    // for text direction.\n    if (node.isLeafBlock()) {\n      const direction = node.getTextDirection()\n      if (direction === 'rtl') attributes.dir = 'rtl'\n    }\n\n    let render\n\n    if (node.object === 'block') {\n      render = 'renderBlock'\n    } else if (node.object === 'document') {\n      render = 'renderDocument'\n    } else if (node.object === 'inline') {\n      render = 'renderInline'\n    }\n\n    const element = editor.run(render, {\n      attributes,\n      children,\n      editor,\n      isFocused: !!selection && selection.isFocused,\n      isSelected: !!selection,\n      node,\n      parent,\n      readOnly,\n    })\n\n    return editor.isVoid(node) ? (\n      <Void\n        {...this.props}\n        textRef={ref => {\n          if (ref) {\n            this.tmp.nodeRefs[0] = ref\n          } else {\n            delete this.tmp.nodeRefs[0]\n          }\n        }}\n      >\n        {element}\n      </Void>\n    ) : (\n      element\n    )\n  }\n}\n\n/**\n * Return a `range` relative to a child at `index`.\n *\n * @param {Range} range\n * @param {Number} index\n * @return {Range}\n */\n\nfunction getRelativeRange(node, index, range) {\n  if (range.isUnset) {\n    return null\n  }\n\n  const child = node.nodes.get(index)\n  let { start, end } = range\n  const { path: startPath } = start\n  const { path: endPath } = end\n  const startIndex = startPath.first()\n  const endIndex = endPath.first()\n\n  if (startIndex === index) {\n    start = start.setPath(startPath.rest())\n  } else if (startIndex < index && index <= endIndex) {\n    if (child.object === 'text') {\n      start = start.moveTo(PathUtils.create([index]), 0)\n    } else {\n      const [first] = child.texts()\n      const [, firstPath] = first\n      start = start.moveTo(firstPath, 0)\n    }\n  } else {\n    start = null\n  }\n\n  if (endIndex === index) {\n    end = end.setPath(endPath.rest())\n  } else if (startIndex <= index && index < endIndex) {\n    if (child.object === 'text') {\n      end = end.moveTo(PathUtils.create([index]), child.text.length)\n    } else {\n      const [last] = child.texts({ direction: 'backward' })\n      const [lastNode, lastPath] = last\n      end = end.moveTo(lastPath, lastNode.text.length)\n    }\n  } else {\n    end = null\n  }\n\n  if (!start || !end) {\n    return null\n  }\n\n  range = range.setStart(start)\n  range = range.setEnd(end)\n  return range\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Node\n","import getWindow from 'get-window'\nimport isBackward from 'selection-is-backward'\nimport { IS_SAFARI, IS_IOS } from 'slate-dev-environment'\n\n/**\n * CSS overflow values that would cause scrolling.\n *\n * @type {Array}\n */\n\nconst OVERFLOWS = ['auto', 'overlay', 'scroll']\n\n/**\n * Detect whether we are running IOS version 11\n */\n\nconst IS_IOS_11 = IS_IOS && !!window.navigator.userAgent.match(/os 11_/i)\n\n/**\n * Find the nearest parent with scrolling, or window.\n *\n * @param {el} Element\n */\n\nfunction findScrollContainer(el, window) {\n  let parent = el.parentNode\n  let scroller\n\n  while (!scroller) {\n    if (!parent.parentNode) break\n\n    const style = window.getComputedStyle(parent)\n    const { overflowY } = style\n\n    if (OVERFLOWS.includes(overflowY)) {\n      scroller = parent\n      break\n    }\n\n    parent = parent.parentNode\n  }\n\n  // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're\n  // assuming that window.scrollTo() should be used if the scrollable element\n  // turns out to be document.body or document.documentElement. This will work\n  // unless body is intentionally set to scrollable by restricting its height\n  // (e.g. height: 100vh).\n  if (!scroller) {\n    return window.document.body\n  }\n\n  return scroller\n}\n\n/**\n * Scroll the current selection's focus point into view if needed.\n *\n * @param {Selection} selection\n */\n\nfunction scrollToSelection(selection) {\n  if (IS_IOS_11) return\n  if (!selection.anchorNode) return\n\n  const window = getWindow(selection.anchorNode)\n  const scroller = findScrollContainer(selection.anchorNode, window)\n  const isWindow =\n    scroller === window.document.body ||\n    scroller === window.document.documentElement\n  const backward = isBackward(selection)\n\n  const range = selection.getRangeAt(0).cloneRange()\n  range.collapse(backward)\n  let cursorRect = range.getBoundingClientRect()\n\n  // COMPAT: range.getBoundingClientRect() returns 0s in Safari when range is\n  // collapsed. Expanding the range by 1 is a relatively effective workaround\n  // for vertical scroll, although horizontal may be off by 1 character.\n  // https://bugs.webkit.org/show_bug.cgi?id=138949\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=435438\n  if (IS_SAFARI) {\n    if (range.collapsed && cursorRect.top === 0 && cursorRect.height === 0) {\n      if (range.startOffset === 0) {\n        range.setEnd(range.endContainer, 1)\n      } else {\n        range.setStart(range.startContainer, range.startOffset - 1)\n      }\n\n      cursorRect = range.getBoundingClientRect()\n\n      if (cursorRect.top === 0 && cursorRect.height === 0) {\n        if (range.getClientRects().length) {\n          cursorRect = range.getClientRects()[0]\n        }\n      }\n    }\n  }\n\n  let width\n  let height\n  let yOffset\n  let xOffset\n  let scrollerTop = 0\n  let scrollerLeft = 0\n  let scrollerBordersY = 0\n  let scrollerBordersX = 0\n  let scrollerPaddingTop = 0\n  let scrollerPaddingBottom = 0\n  let scrollerPaddingLeft = 0\n  let scrollerPaddingRight = 0\n\n  if (isWindow) {\n    const { innerWidth, innerHeight, pageYOffset, pageXOffset } = window\n    width = innerWidth\n    height = innerHeight\n    yOffset = pageYOffset\n    xOffset = pageXOffset\n  } else {\n    const { offsetWidth, offsetHeight, scrollTop, scrollLeft } = scroller\n    const {\n      borderTopWidth,\n      borderBottomWidth,\n      borderLeftWidth,\n      borderRightWidth,\n      paddingTop,\n      paddingBottom,\n      paddingLeft,\n      paddingRight,\n    } = window.getComputedStyle(scroller)\n\n    const scrollerRect = scroller.getBoundingClientRect()\n    width = offsetWidth\n    height = offsetHeight\n    scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10)\n    scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10)\n\n    scrollerBordersY =\n      parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10)\n\n    scrollerBordersX =\n      parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10)\n\n    scrollerPaddingTop = parseInt(paddingTop, 10)\n    scrollerPaddingBottom = parseInt(paddingBottom, 10)\n    scrollerPaddingLeft = parseInt(paddingLeft, 10)\n    scrollerPaddingRight = parseInt(paddingRight, 10)\n    yOffset = scrollTop\n    xOffset = scrollLeft\n  }\n\n  const cursorTop = cursorRect.top + yOffset - scrollerTop\n  const cursorLeft = cursorRect.left + xOffset - scrollerLeft\n\n  let x = xOffset\n  let y = yOffset\n\n  if (cursorLeft < xOffset) {\n    // selection to the left of viewport\n    x = cursorLeft - scrollerPaddingLeft\n  } else if (\n    cursorLeft + cursorRect.width + scrollerBordersX >\n    xOffset + width\n  ) {\n    // selection to the right of viewport\n    x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width\n  }\n\n  if (cursorTop < yOffset) {\n    // selection above viewport\n    y = cursorTop - scrollerPaddingTop\n  } else if (\n    cursorTop + cursorRect.height + scrollerBordersY >\n    yOffset + height\n  ) {\n    // selection below viewport\n    y =\n      cursorTop +\n      scrollerBordersY +\n      scrollerPaddingBottom +\n      cursorRect.height -\n      height\n  }\n\n  if (isWindow) {\n    window.scrollTo(x, y)\n  } else {\n    scroller.scrollTop = y\n    scroller.scrollLeft = x\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default scrollToSelection\n","import { IS_IE } from 'slate-dev-environment'\n\n/**\n * Cross-browser remove all ranges from a `domSelection`.\n *\n * @param {Selection} domSelection\n */\n\nfunction removeAllRanges(domSelection) {\n  // COMPAT: In IE 11, if the selection contains nested tables, then\n  // `removeAllRanges` will throw an error.\n  if (IS_IE) {\n    const range = window.document.body.createTextRange()\n    range.collapse()\n    range.select()\n  } else {\n    domSelection.removeAllRanges()\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default removeAllRanges\n","import Debug from 'debug'\nimport React from 'react'\nimport Types from 'prop-types'\nimport getWindow from 'get-window'\nimport warning from 'tiny-warning'\nimport throttle from 'lodash/throttle'\nimport { List } from 'immutable'\nimport {\n  IS_ANDROID,\n  IS_FIREFOX,\n  HAS_INPUT_EVENTS_LEVEL_2,\n} from 'slate-dev-environment'\n\nimport EVENT_HANDLERS from '../constants/event-handlers'\nimport DATA_ATTRS from '../constants/data-attributes'\nimport SELECTORS from '../constants/selectors'\nimport Node from './node'\nimport scrollToSelection from '../utils/scroll-to-selection'\nimport removeAllRanges from '../utils/remove-all-ranges'\n\nconst FIREFOX_NODE_TYPE_ACCESS_ERROR = /Permission denied to access property \"nodeType\"/\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:content')\n\n/**\n * Separate debug to easily see when the DOM has updated either by render or\n * changing selection.\n *\n * @type {Function}\n */\n\ndebug.update = Debug('slate:update')\n\n/**\n * Content.\n *\n * @type {Component}\n */\n\nclass Content extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    autoCorrect: Types.bool.isRequired,\n    className: Types.string,\n    contentKey: Types.number,\n    editor: Types.object.isRequired,\n    id: Types.string,\n    readOnly: Types.bool.isRequired,\n    role: Types.string,\n    spellCheck: Types.bool.isRequired,\n    style: Types.object,\n    tabIndex: Types.number,\n    tagName: Types.string,\n  }\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  static defaultProps = {\n    style: {},\n    tagName: 'div',\n  }\n\n  /**\n   * An error boundary. If there is a render error, we increment `errorKey`\n   * which is part of the container `key` which forces a re-render from\n   * scratch.\n   *\n   * @param {Error} error\n   * @param {String} info\n   */\n\n  componentDidCatch(error, info) {\n    debug('componentDidCatch', { error, info })\n    // The call to `setState` is required despite not setting a value.\n    // Without this call, React will not try to recreate the component tree.\n    this.setState({})\n  }\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  tmp = {\n    isUpdatingSelection: false,\n    nodeRef: React.createRef(),\n    nodeRefs: {},\n  }\n\n  /**\n   * A ref for the contenteditable DOM node.\n   *\n   * @type {Object}\n   */\n\n  ref = React.createRef()\n\n  /**\n   * Create a set of bound event handlers.\n   *\n   * @type {Object}\n   */\n\n  handlers = EVENT_HANDLERS.reduce((obj, handler) => {\n    obj[handler] = event => this.onEvent(handler, event)\n    return obj\n  }, {})\n\n  /**\n   * When the editor first mounts in the DOM we need to:\n   *\n   *   - Add native DOM event listeners.\n   *   - Update the selection, in case it starts focused.\n   */\n\n  componentDidMount() {\n    const window = getWindow(this.ref.current)\n\n    window.document.addEventListener(\n      'selectionchange',\n      this.onNativeSelectionChange\n    )\n\n    // COMPAT: Restrict scope of `beforeinput` to clients that support the\n    // Input Events Level 2 spec, since they are preventable events.\n    if (HAS_INPUT_EVENTS_LEVEL_2) {\n      this.ref.current.addEventListener(\n        'beforeinput',\n        this.handlers.onBeforeInput\n      )\n    }\n\n    this.updateSelection()\n  }\n\n  /**\n   * When unmounting, remove DOM event listeners.\n   */\n\n  componentWillUnmount() {\n    const window = getWindow(this.ref.current)\n\n    if (window) {\n      window.document.removeEventListener(\n        'selectionchange',\n        this.onNativeSelectionChange\n      )\n    }\n\n    if (HAS_INPUT_EVENTS_LEVEL_2) {\n      this.ref.current.removeEventListener(\n        'beforeinput',\n        this.handlers.onBeforeInput\n      )\n    }\n  }\n\n  /**\n   * On update, update the selection.\n   */\n\n  componentDidUpdate() {\n    debug.update('componentDidUpdate')\n    this.updateSelection()\n  }\n\n  /**\n   * Update the native DOM selection to reflect the internal model.\n   */\n\n  updateSelection = () => {\n    const { editor } = this.props\n    const { value } = editor\n    const { selection } = value\n    const { isBackward } = selection\n    const window = getWindow(this.ref.current)\n    const native = window.getSelection()\n    const { activeElement } = window.document\n\n    if (debug.enabled) {\n      debug.update('updateSelection', { selection: selection.toJSON() })\n    }\n\n    // COMPAT: In Firefox, there's a but where `getSelection` can return `null`.\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=827585 (2018/11/07)\n    if (!native) {\n      return\n    }\n\n    const { rangeCount, anchorNode } = native\n    let updated = false\n\n    // If the Slate selection is blurred, but the DOM's active element is still\n    // the editor, we need to blur it.\n    if (selection.isBlurred && activeElement === this.ref.current) {\n      this.ref.current.blur()\n      updated = true\n    }\n\n    // If the Slate selection is unset, but the DOM selection has a range\n    // selected in the editor, we need to remove the range.\n    if (selection.isUnset && rangeCount && this.isInEditor(anchorNode)) {\n      removeAllRanges(native)\n      updated = true\n    }\n\n    // If the Slate selection is focused, but the DOM's active element is not\n    // the editor, we need to focus it. We prevent scrolling because we handle\n    // scrolling to the correct selection.\n    if (selection.isFocused && activeElement !== this.ref.current) {\n      this.ref.current.focus({ preventScroll: true })\n      updated = true\n    }\n\n    // Otherwise, figure out which DOM nodes should be selected...\n    if (selection.isFocused && selection.isSet) {\n      const current = !!rangeCount && native.getRangeAt(0)\n      const range = editor.findDOMRange(selection)\n\n      if (!range) {\n        warning(\n          false,\n          'Unable to find a native DOM range from the current selection.'\n        )\n\n        return\n      }\n\n      const { startContainer, startOffset, endContainer, endOffset } = range\n\n      // If the new range matches the current selection, there is nothing to fix.\n      // COMPAT: The native `Range` object always has it's \"start\" first and \"end\"\n      // last in the DOM. It has no concept of \"backwards/forwards\", so we have\n      // to check both orientations here. (2017/10/31)\n      if (current) {\n        if (\n          (startContainer === current.startContainer &&\n            startOffset === current.startOffset &&\n            endContainer === current.endContainer &&\n            endOffset === current.endOffset) ||\n          (startContainer === current.endContainer &&\n            startOffset === current.endOffset &&\n            endContainer === current.startContainer &&\n            endOffset === current.startOffset)\n        ) {\n          return\n        }\n      }\n\n      // Otherwise, set the `isUpdatingSelection` flag and update the selection.\n      updated = true\n      this.tmp.isUpdatingSelection = true\n      removeAllRanges(native)\n\n      // COMPAT: IE 11 does not support `setBaseAndExtent`. (2018/11/07)\n      if (native.setBaseAndExtent) {\n        // COMPAT: Since the DOM range has no concept of backwards/forwards\n        // we need to check and do the right thing here.\n        if (isBackward) {\n          native.setBaseAndExtent(\n            range.endContainer,\n            range.endOffset,\n            range.startContainer,\n            range.startOffset\n          )\n        } else {\n          native.setBaseAndExtent(\n            range.startContainer,\n            range.startOffset,\n            range.endContainer,\n            range.endOffset\n          )\n        }\n      } else {\n        native.addRange(range)\n      }\n\n      // Scroll to the selection, in case it's out of view.\n      scrollToSelection(native)\n\n      // Then unset the `isUpdatingSelection` flag after a delay, to ensure that\n      // it is still set when selection-related events from updating it fire.\n      setTimeout(() => {\n        // COMPAT: In Firefox, it's not enough to create a range, you also need\n        // to focus the contenteditable element too. (2016/11/16)\n        if (IS_FIREFOX && this.ref.current) {\n          this.ref.current.focus()\n        }\n\n        this.tmp.isUpdatingSelection = false\n      })\n    }\n\n    if (updated && debug.enabled) {\n      debug('updateSelection', { selection, native, activeElement })\n      debug.update('updateSelection-applied', { selection })\n    }\n  }\n\n  /**\n   * Check if an event `target` is fired from within the contenteditable\n   * element. This should be false for edits happening in non-contenteditable\n   * children, such as void nodes and other nested Slate editors.\n   *\n   * @param {Element} target\n   * @return {Boolean}\n   */\n\n  isInEditor = target => {\n    let el\n\n    try {\n      // COMPAT: In Firefox, sometimes the node can be comment which doesn't\n      // have .closest and it crashes.\n      if (target.nodeType === 8) {\n        return false\n      }\n\n      // COMPAT: Text nodes don't have `isContentEditable` property. So, when\n      // `target` is a text node use its parent node for check.\n      el = target.nodeType === 3 ? target.parentNode : target\n    } catch (err) {\n      // COMPAT: In Firefox, `target.nodeType` will throw an error if target is\n      // originating from an internal \"restricted\" element (e.g. a stepper\n      // arrow on a number input)\n      // see github.com/ianstormtaylor/slate/issues/1819\n      if (IS_FIREFOX && FIREFOX_NODE_TYPE_ACCESS_ERROR.test(err.message)) {\n        return false\n      }\n\n      throw err\n    }\n\n    return (\n      el.isContentEditable &&\n      (el === this.ref.current ||\n        el.closest(SELECTORS.EDITOR) === this.ref.current)\n    )\n  }\n\n  /**\n   * On `event` with `handler`.\n   *\n   * @param {String} handler\n   * @param {Event} event\n   */\n\n  onEvent(handler, event) {\n    debug('onEvent', handler)\n\n    // Ignore `onBlur`, `onFocus` and `onSelect` events generated\n    // programmatically while updating selection.\n    if (\n      this.tmp.isUpdatingSelection &&\n      (handler === 'onSelect' || handler === 'onBlur' || handler === 'onFocus')\n    ) {\n      return\n    }\n\n    // COMPAT: There are situations where a select event will fire with a new\n    // native selection that resolves to the same internal position. In those\n    // cases we don't need to trigger any changes, since our internal model is\n    // already up to date, but we do want to update the native selection again\n    // to make sure it is in sync. (2017/10/16)\n    //\n    // ANDROID: The updateSelection causes issues in Android when you are\n    // at the end of a block. The selection ends up to the left of the inserted\n    // character instead of to the right. This behavior continues even if\n    // you enter more than one character. (2019/01/03)\n    if (!IS_ANDROID && handler === 'onSelect') {\n      const { editor } = this.props\n      const { value } = editor\n      const { selection } = value\n      const window = getWindow(event.target)\n      const domSelection = window.getSelection()\n      const range = editor.findRange(domSelection)\n\n      if (range && range.equals(selection.toRange())) {\n        this.updateSelection()\n        return\n      }\n    }\n\n    // Don't handle drag and drop events coming from embedded editors.\n    if (\n      handler === 'onDragEnd' ||\n      handler === 'onDragEnter' ||\n      handler === 'onDragExit' ||\n      handler === 'onDragLeave' ||\n      handler === 'onDragOver' ||\n      handler === 'onDragStart' ||\n      handler === 'onDrop'\n    ) {\n      const closest = event.target.closest(SELECTORS.EDITOR)\n\n      if (closest !== this.ref.current) {\n        return\n      }\n    }\n\n    // Some events require being in editable in the editor, so if the event\n    // target isn't, ignore them.\n    if (\n      handler === 'onBeforeInput' ||\n      handler === 'onBlur' ||\n      handler === 'onCompositionEnd' ||\n      handler === 'onCompositionStart' ||\n      handler === 'onCopy' ||\n      handler === 'onCut' ||\n      handler === 'onFocus' ||\n      handler === 'onInput' ||\n      handler === 'onKeyDown' ||\n      handler === 'onKeyUp' ||\n      handler === 'onPaste' ||\n      handler === 'onSelect'\n    ) {\n      if (!this.isInEditor(event.target)) {\n        return\n      }\n    }\n\n    this.props.onEvent(handler, event)\n  }\n\n  /**\n   * On native `selectionchange` event, trigger the `onSelect` handler. This is\n   * needed to account for React's `onSelect` being non-standard and not firing\n   * until after a selection has been released. This causes issues in situations\n   * where another change happens while a selection is being made.\n   *\n   * @param {Event} event\n   */\n\n  onNativeSelectionChange = throttle(event => {\n    if (this.props.readOnly) return\n\n    const window = getWindow(event.target)\n    const { activeElement } = window.document\n    if (activeElement !== this.ref.current) return\n\n    this.props.onEvent('onSelect', event)\n  }, 100)\n\n  /**\n   * Render the editor content.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    const { props, handlers } = this\n    const {\n      id,\n      className,\n      readOnly,\n      editor,\n      tabIndex,\n      role,\n      tagName,\n      spellCheck,\n    } = props\n    const { value } = editor\n    const Container = tagName\n    const { document, selection } = value\n\n    const style = {\n      // Prevent the default outline styles.\n      outline: 'none',\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: 'pre-wrap',\n      // Allow words to break if they are too long.\n      wordWrap: 'break-word',\n      // COMPAT: In iOS, a formatting menu with bold, italic and underline\n      // buttons is shown which causes our internal value to get out of sync in\n      // weird ways. This hides that. (2016/06/21)\n      ...(readOnly ? {} : { WebkitUserModify: 'read-write-plaintext-only' }),\n      // Allow for passed-in styles to override anything.\n      ...props.style,\n    }\n\n    debug('render', { props })\n\n    const data = {\n      [DATA_ATTRS.EDITOR]: true,\n      [DATA_ATTRS.KEY]: document.key,\n    }\n\n    return (\n      <Container\n        key={this.props.contentKey}\n        {...handlers}\n        {...data}\n        ref={this.ref}\n        contentEditable={readOnly ? null : true}\n        suppressContentEditableWarning\n        id={id}\n        className={className}\n        autoCorrect={props.autoCorrect ? 'on' : 'off'}\n        spellCheck={spellCheck}\n        style={style}\n        role={readOnly ? null : role || 'textbox'}\n        tabIndex={tabIndex}\n        // COMPAT: The Grammarly Chrome extension works by changing the DOM out\n        // from under `contenteditable` elements, which leads to weird behaviors\n        // so we have to disable it like this. (2017/04/24)\n        data-gramm={false}\n      >\n        <Node\n          annotations={value.annotations}\n          block={null}\n          decorations={List()}\n          editor={editor}\n          node={document}\n          parent={null}\n          readOnly={readOnly}\n          selection={selection}\n          ref={this.tmp.nodeRef}\n        />\n      </Container>\n    )\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Content\n","import EVENT_HANDLERS from '../../constants/event-handlers'\n\n/**\n * Props that can be defined by plugins.\n *\n * @type {Array}\n */\n\nconst PROPS = [\n  ...EVENT_HANDLERS,\n  'commands',\n  'decorateNode',\n  'queries',\n  'renderAnnotation',\n  'renderBlock',\n  'renderDecoration',\n  'renderDocument',\n  'renderEditor',\n  'renderInline',\n  'renderMark',\n  'schema',\n]\n\n/**\n * The top-level editor props in a plugin.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction EditorPropsPlugin(options = {}) {\n  const plugin = PROPS.reduce((memo, prop) => {\n    if (prop in options) memo[prop] = options[prop]\n    return memo\n  }, {})\n\n  return plugin\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default EditorPropsPlugin\n","import React from 'react'\n\n/**\n * The default rendering behavior for the React plugin.\n *\n * @return {Object}\n */\n\nfunction Rendering() {\n  return {\n    decorateNode() {\n      return []\n    },\n\n    renderAnnotation({ attributes, children }) {\n      return <span {...attributes}>{children}</span>\n    },\n\n    renderBlock({ attributes, children }) {\n      return (\n        <div {...attributes} style={{ position: 'relative' }}>\n          {children}\n        </div>\n      )\n    },\n\n    renderDecoration({ attributes, children }) {\n      return <span {...attributes}>{children}</span>\n    },\n\n    renderDocument({ children }) {\n      return children\n    },\n\n    renderEditor({ children }) {\n      return children\n    },\n\n    renderInline({ attributes, children }) {\n      return (\n        <span {...attributes} style={{ position: 'relative' }}>\n          {children}\n        </span>\n      )\n    },\n\n    renderMark({ attributes, children }) {\n      return <span {...attributes}>{children}</span>\n    },\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default Rendering\n","/**\n * A set of commands for the React plugin.\n *\n * @return {Object}\n */\n\nfunction CommandsPlugin() {\n  /**\n   * Takes a `node`, find the matching `domNode` and uses it to set the text\n   * in the `node`.\n   *\n   * @param {Editor} editor\n   * @param {Node} node\n   */\n\n  function reconcileNode(editor, node) {\n    const { value } = editor\n    const { document, selection } = value\n    const path = document.getPath(node.key)\n\n    const domElement = editor.findDOMNode(path)\n    const block = document.getClosestBlock(path)\n\n    // Get text information\n    const { text } = node\n    let { textContent: domText } = domElement\n\n    const isLastNode = block.nodes.last() === node\n    const lastChar = domText.charAt(domText.length - 1)\n\n    // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n    // we will have added another new line in <Leaf>'s render method to account\n    // for browsers collapsing a single trailing new lines, so remove it.\n    if (isLastNode && lastChar === '\\n') {\n      domText = domText.slice(0, -1)\n    }\n\n    // If the text is no different, abort.\n    if (text === domText) return\n\n    let entire = selection.moveAnchorTo(path, 0).moveFocusTo(path, text.length)\n\n    entire = document.resolveRange(entire)\n\n    // Change the current value to have the leaf's text replaced.\n    editor.insertTextAtRange(entire, domText, node.marks)\n    return\n  }\n\n  /**\n   * Takes text from the `domNode` and uses it to set the text in the matching\n   * `node` in Slate.\n   *\n   * @param {Editor} editor\n   * @param {DOMNode} domNode\n   */\n\n  function reconcileDOMNode(editor, domNode) {\n    const domElement = domNode.parentElement.closest('[data-key]')\n    const node = editor.findNode(domElement)\n    editor.reconcileNode(node)\n  }\n\n  return {\n    commands: {\n      reconcileNode,\n      reconcileDOMNode,\n    },\n  }\n}\n\nexport default CommandsPlugin\n","import getWindow from 'get-window'\nimport { PathUtils } from 'slate'\n\nimport DATA_ATTRS from '../../constants/data-attributes'\nimport SELECTORS from '../../constants/selectors'\n\n/**\n * A set of queries for the React plugin.\n *\n * @return {Object}\n */\n\nfunction QueriesPlugin() {\n  /**\n   * Find the native DOM element for a node at `path`.\n   *\n   * @param {Editor} editor\n   * @param {Array|List} path\n   * @return {DOMNode|Null}\n   */\n\n  function findDOMNode(editor, path) {\n    path = PathUtils.create(path)\n    const content = editor.tmp.contentRef.current\n\n    if (!content) {\n      return null\n    }\n\n    if (!path.size) {\n      return content.ref.current || null\n    }\n\n    const search = (instance, p) => {\n      if (!instance) {\n        return null\n      }\n\n      if (!p.size) {\n        if (instance.ref) {\n          return instance.ref.current || null\n        } else {\n          return instance || null\n        }\n      }\n\n      const index = p.first()\n      const rest = p.rest()\n      const ref = instance.tmp.nodeRefs[index]\n      return search(ref, rest)\n    }\n\n    const document = content.tmp.nodeRef.current\n    const el = search(document, path)\n    return el\n  }\n\n  /**\n   * Find a native DOM selection point from a Slate `point`.\n   *\n   * @param {Editor} editor\n   * @param {Point} point\n   * @return {Object|Null}\n   */\n\n  function findDOMPoint(editor, point) {\n    const el = editor.findDOMNode(point.path)\n    let start = 0\n\n    if (!el) {\n      return null\n    }\n\n    // For each leaf, we need to isolate its content, which means filtering to its\n    // direct text and zero-width spans. (We have to filter out any other siblings\n    // that may have been rendered alongside them.)\n    const texts = Array.from(\n      el.querySelectorAll(`${SELECTORS.STRING}, ${SELECTORS.ZERO_WIDTH}`)\n    )\n\n    for (const text of texts) {\n      const node = text.childNodes[0]\n      const domLength = node.textContent.length\n      let slateLength = domLength\n\n      if (text.hasAttribute(DATA_ATTRS.LENGTH)) {\n        slateLength = parseInt(text.getAttribute(DATA_ATTRS.LENGTH), 10)\n      }\n\n      const end = start + slateLength\n\n      if (point.offset <= end) {\n        const offset = Math.min(domLength, Math.max(0, point.offset - start))\n        return { node, offset }\n      }\n\n      start = end\n    }\n\n    return null\n  }\n\n  /**\n   * Find a native DOM range from a Slate `range`.\n   *\n   * @param {Editor} editor\n   * @param {Range} range\n   * @return {DOMRange|Null}\n   */\n\n  function findDOMRange(editor, range) {\n    const { anchor, focus, isBackward, isCollapsed } = range\n    const domAnchor = editor.findDOMPoint(anchor)\n    const domFocus = isCollapsed ? domAnchor : editor.findDOMPoint(focus)\n\n    if (!domAnchor || !domFocus) {\n      return null\n    }\n\n    const window = getWindow(domAnchor.node)\n    const r = window.document.createRange()\n    const start = isBackward ? domFocus : domAnchor\n    const end = isBackward ? domAnchor : domFocus\n    r.setStart(start.node, start.offset)\n    r.setEnd(end.node, end.offset)\n    return r\n  }\n\n  /**\n   * Find a Slate node from a native DOM `element`.\n   *\n   * @param {Editor} editor\n   * @param {Element} element\n   * @return {List|Null}\n   */\n\n  function findNode(editor, element) {\n    const path = editor.findPath(element)\n\n    if (!path) {\n      return null\n    }\n\n    const { value } = editor\n    const { document } = value\n    const node = document.getNode(path)\n    return node\n  }\n\n  /**\n   * Get the target range from a DOM `event`.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @return {Range}\n   */\n\n  function findEventRange(editor, event) {\n    if (event.nativeEvent) {\n      event = event.nativeEvent\n    }\n\n    const { clientX: x, clientY: y, target } = event\n    if (x == null || y == null) return null\n\n    const { value } = editor\n    const { document } = value\n    const path = editor.findPath(event.target)\n    if (!path) return null\n\n    const node = document.getNode(path)\n\n    // If the drop target is inside a void node, move it into either the next or\n    // previous node, depending on which side the `x` and `y` coordinates are\n    // closest to.\n    if (editor.isVoid(node)) {\n      const rect = target.getBoundingClientRect()\n      const isPrevious =\n        node.object === 'inline'\n          ? x - rect.left < rect.left + rect.width - x\n          : y - rect.top < rect.top + rect.height - y\n\n      const range = document.createRange()\n      const move = isPrevious ? 'moveToEndOfNode' : 'moveToStartOfNode'\n      const entry = document[isPrevious ? 'getPreviousText' : 'getNextText'](\n        path\n      )\n\n      if (entry) {\n        return range[move](entry)\n      }\n\n      return null\n    }\n\n    // Else resolve a range from the caret position where the drop occured.\n    const window = getWindow(target)\n    let native\n\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (window.document.caretRangeFromPoint) {\n      native = window.document.caretRangeFromPoint(x, y)\n    } else if (window.document.caretPositionFromPoint) {\n      const position = window.document.caretPositionFromPoint(x, y)\n      native = window.document.createRange()\n      native.setStart(position.offsetNode, position.offset)\n      native.setEnd(position.offsetNode, position.offset)\n    } else if (window.document.body.createTextRange) {\n      // COMPAT: In IE, `caretRangeFromPoint` and\n      // `caretPositionFromPoint` don't exist. (2018/07/11)\n      native = window.document.body.createTextRange()\n\n      try {\n        native.moveToPoint(x, y)\n      } catch (error) {\n        // IE11 will raise an `unspecified error` if `moveToPoint` is\n        // called during a dropEvent.\n        return null\n      }\n    }\n\n    // Resolve a Slate range from the DOM range.\n    const range = editor.findRange(native)\n    return range\n  }\n\n  /**\n   * Find the path of a native DOM `element` by searching React refs.\n   *\n   * @param {Editor} editor\n   * @param {Element} element\n   * @return {List|Null}\n   */\n\n  function findPath(editor, element) {\n    const content = editor.tmp.contentRef.current\n    let nodeElement = element\n\n    // If element does not have a key, it is likely a string or\n    // mark, return the closest parent Node that can be looked up.\n    if (!nodeElement.hasAttribute(DATA_ATTRS.KEY)) {\n      nodeElement = nodeElement.closest(SELECTORS.KEY)\n    }\n\n    if (!nodeElement || !nodeElement.getAttribute(DATA_ATTRS.KEY)) {\n      return null\n    }\n\n    if (nodeElement === content.ref.current) {\n      return PathUtils.create([])\n    }\n\n    const search = (instance, p) => {\n      if (nodeElement === instance) {\n        return p\n      }\n\n      if (!instance.ref) {\n        return null\n      }\n\n      if (nodeElement === instance.ref.current) {\n        return p\n      }\n\n      // If there's no `tmp` then we're at a leaf node without success.\n      if (!instance.tmp) {\n        return null\n      }\n\n      const { nodeRefs } = instance.tmp\n      const keys = Object.keys(nodeRefs)\n\n      for (const i of keys) {\n        const ref = nodeRefs[i]\n        const n = parseInt(i, 10)\n        const path = search(ref, [...p, n])\n\n        if (path) {\n          return path\n        }\n      }\n\n      return null\n    }\n\n    const document = content.tmp.nodeRef.current\n    const path = search(document, [])\n\n    if (!path) {\n      return null\n    }\n\n    return PathUtils.create(path)\n  }\n\n  /**\n   * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n   *\n   * @param {Editor} editor\n   * @param {Element} nativeNode\n   * @param {Number} nativeOffset\n   * @return {Point}\n   */\n\n  function findPoint(editor, nativeNode, nativeOffset) {\n    const { node: nearestNode, offset: nearestOffset } = normalizeNodeAndOffset(\n      nativeNode,\n      nativeOffset\n    )\n\n    const window = getWindow(nativeNode)\n    const { parentNode } = nearestNode\n    let leafNode = parentNode.closest(SELECTORS.LEAF)\n    let textNode\n    let offset\n    let node\n\n    // Calculate how far into the text node the `nearestNode` is, so that we can\n    // determine what the offset relative to the text node is.\n    if (leafNode) {\n      textNode = leafNode.closest(SELECTORS.TEXT)\n      const range = window.document.createRange()\n      range.setStart(textNode, 0)\n      range.setEnd(nearestNode, nearestOffset)\n      const contents = range.cloneContents()\n      const zeroWidths = contents.querySelectorAll(SELECTORS.ZERO_WIDTH)\n\n      Array.from(zeroWidths).forEach(el => {\n        el.parentNode.removeChild(el)\n      })\n\n      // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\n\n      // into \\r\\n. The bug causes a loop when slate-react attempts to reposition\n      // its cursor to match the native position. Use textContent.length instead.\n      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n      offset = contents.textContent.length\n      node = textNode\n    } else {\n      // For void nodes, the element with the offset key will be a cousin, not an\n      // ancestor, so find it by going down from the nearest void parent.\n      const voidNode = parentNode.closest(SELECTORS.VOID)\n\n      if (!voidNode) {\n        return null\n      }\n\n      leafNode = voidNode.querySelector(SELECTORS.LEAF)\n\n      if (!leafNode) {\n        return null\n      }\n\n      textNode = leafNode.closest(SELECTORS.TEXT)\n      node = leafNode\n      offset = node.textContent.length\n    }\n\n    // COMPAT: If the parent node is a Slate zero-width space, this is because the\n    // text node should have no characters. However, during IME composition the\n    // ASCII characters will be prepended to the zero-width space, so subtract 1\n    // from the offset to account for the zero-width space character.\n    if (\n      offset === node.textContent.length &&\n      parentNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)\n    ) {\n      offset--\n    }\n\n    // COMPAT: If someone is clicking from one Slate editor into another, the\n    // select event fires twice, once for the old editor's `element` first, and\n    // then afterwards for the correct `element`. (2017/03/03)\n    const path = editor.findPath(textNode)\n\n    if (!path) {\n      return null\n    }\n\n    const { value } = editor\n    const { document } = value\n    const point = document.createPoint({ path, offset })\n    return point\n  }\n\n  /**\n   * Find a Slate range from a DOM range or selection.\n   *\n   * @param {Editor} editor\n   * @param {Selection} domRange\n   * @return {Range}\n   */\n\n  function findRange(editor, domRange) {\n    const el = domRange.anchorNode || domRange.startContainer\n\n    if (!el) {\n      return null\n    }\n\n    const window = getWindow(el)\n\n    // If the `domRange` object is a DOM `Range` or `StaticRange` object, change it\n    // into something that looks like a DOM `Selection` instead.\n    if (\n      domRange instanceof window.Range ||\n      (window.StaticRange && domRange instanceof window.StaticRange)\n    ) {\n      domRange = {\n        anchorNode: domRange.startContainer,\n        anchorOffset: domRange.startOffset,\n        focusNode: domRange.endContainer,\n        focusOffset: domRange.endOffset,\n      }\n    }\n\n    const {\n      anchorNode,\n      anchorOffset,\n      focusNode,\n      focusOffset,\n      isCollapsed,\n    } = domRange\n    const { value } = editor\n    const anchor = editor.findPoint(anchorNode, anchorOffset)\n    const focus = isCollapsed\n      ? anchor\n      : editor.findPoint(focusNode, focusOffset)\n\n    if (!anchor || !focus) {\n      return null\n    }\n\n    const { document } = value\n    const range = document.createRange({\n      anchor,\n      focus,\n    })\n\n    return range\n  }\n\n  /**\n   * Find a Slate selection from a DOM selection.\n   *\n   * @param {Editor} editor\n   * @param {Selection} domSelection\n   * @return {Range}\n   */\n\n  function findSelection(editor, domSelection) {\n    const { value } = editor\n    const { document } = value\n\n    // If there are no ranges, the editor was blurred natively.\n    if (!domSelection.rangeCount) {\n      return null\n    }\n\n    // Otherwise, determine the Slate selection from the native one.\n    let range = editor.findRange(domSelection)\n\n    if (!range) {\n      return null\n    }\n\n    const { anchor, focus } = range\n    const anchorText = document.getNode(anchor.path)\n    const focusText = document.getNode(focus.path)\n    const anchorInline = document.getClosestInline(anchor.path)\n    const focusInline = document.getClosestInline(focus.path)\n    const focusBlock = document.getClosestBlock(focus.path)\n    const anchorBlock = document.getClosestBlock(anchor.path)\n\n    // COMPAT: If the anchor point is at the start of a non-void, and the\n    // focus point is inside a void node with an offset that isn't `0`, set\n    // the focus offset to `0`. This is due to void nodes <span>'s being\n    // positioned off screen, resulting in the offset always being greater\n    // than `0`. Since we can't know what it really should be, and since an\n    // offset of `0` is less destructive because it creates a hanging\n    // selection, go with `0`. (2017/09/07)\n    if (\n      anchorBlock &&\n      !editor.isVoid(anchorBlock) &&\n      anchor.offset === 0 &&\n      focusBlock &&\n      editor.isVoid(focusBlock) &&\n      focus.offset !== 0\n    ) {\n      range = range.setFocus(focus.setOffset(0))\n    }\n\n    // COMPAT: If the selection is at the end of a non-void inline node, and\n    // there is a node after it, put it in the node after instead. This\n    // standardizes the behavior, since it's indistinguishable to the user.\n    if (\n      anchorInline &&\n      !editor.isVoid(anchorInline) &&\n      anchor.offset === anchorText.text.length\n    ) {\n      const block = document.getClosestBlock(anchor.path)\n      const depth = document.getDepth(block.key)\n      const relativePath = PathUtils.drop(anchor.path, depth)\n      const [next] = block.texts({ path: relativePath })\n\n      if (next) {\n        const [, nextPath] = next\n        const absolutePath = anchor.path.slice(0, depth).concat(nextPath)\n        range = range.moveAnchorTo(absolutePath, 0)\n      }\n    }\n\n    if (\n      focusInline &&\n      !editor.isVoid(focusInline) &&\n      focus.offset === focusText.text.length\n    ) {\n      const block = document.getClosestBlock(focus.path)\n      const depth = document.getDepth(block.key)\n      const relativePath = PathUtils.drop(focus.path, depth)\n      const [next] = block.texts({ path: relativePath })\n\n      if (next) {\n        const [, nextPath] = next\n        const absolutePath = focus.path.slice(0, depth).concat(nextPath)\n        range = range.moveFocusTo(absolutePath, 0)\n      }\n    }\n\n    let selection = document.createSelection(range)\n\n    // COMPAT: Ensure that the `isFocused` argument is set.\n    selection = selection.setIsFocused(true)\n\n    // COMPAT: Preserve the marks, since we have no way of knowing what the DOM\n    // selection's marks were. They will be cleared automatically by the\n    // `select` command if the selection moves.\n    selection = selection.set('marks', value.selection.marks)\n\n    return selection\n  }\n\n  return {\n    queries: {\n      findDOMNode,\n      findDOMPoint,\n      findDOMRange,\n      findEventRange,\n      findNode,\n      findPath,\n      findPoint,\n      findRange,\n      findSelection,\n    },\n  }\n}\n\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType === 1 && node.childNodes.length) {\n    const isLast = offset === node.childNodes.length\n    const direction = isLast ? 'backward' : 'forward'\n    const index = isLast ? offset - 1 : offset\n    node = getEditableChild(node, index, direction)\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (node.nodeType === 1 && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, direction)\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return { node, offset }\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\nfunction getEditableChild(parent, index, direction) {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (\n    child.nodeType === 8 ||\n    (child.nodeType === 1 && child.childNodes.length === 0) ||\n    (child.nodeType === 1 && child.getAttribute('contenteditable') === 'false')\n  ) {\n    if (triedForward && triedBackward) break\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    if (direction === 'forward') i++\n    if (direction === 'backward') i--\n  }\n\n  return child || null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default QueriesPlugin\n","/**\n * Fixes a selection within the DOM when the cursor is in Slate's special\n * zero-width block. Slate handles empty blocks in a special manner and the\n * cursor can end up either before or after the non-breaking space. This\n * causes different behavior in Android and so we make sure the seleciton is\n * always before the zero-width space.\n *\n * @param {Window} window\n */\n\nexport default function fixSelectionInZeroWidthBlock(window) {\n  const domSelection = window.getSelection()\n  const { anchorNode } = domSelection\n  const { dataset } = anchorNode.parentElement\n  const isZeroWidth = dataset ? dataset.slateZeroWidth === 'n' : false\n\n  // We are doing three checks to see if we need to move the cursor.\n  // Is this a zero-width slate span?\n  // Is the current cursor position not at the start of it?\n  // Is there more than one character (i.e. the zero-width space char) in here?\n  if (\n    isZeroWidth &&\n    anchorNode.textContent.length === 1 &&\n    domSelection.anchorOffset !== 0\n  ) {\n    const range = window.document.createRange()\n    range.setStart(anchorNode, 0)\n    range.setEnd(anchorNode, 0)\n    domSelection.removeAllRanges()\n    domSelection.addRange(range)\n  }\n}\n","import getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Value } from 'slate'\n\nimport OffsetKey from './offset-key'\nimport DATA_ATTRS from '../constants/data-attributes'\nimport SELECTORS from '../constants/selectors'\n\n/**\n * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n *\n * @param {Element} nativeNode\n * @param {Number} nativeOffset\n * @param {Editor} editor\n * @return {Point}\n */\n\nfunction findPoint(nativeNode, nativeOffset, editor) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findPoint(node, offset)` helper is deprecated in favor of `editor.findPoint(node, offset)`.'\n  )\n\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findPoint` utility takes an `editor` instead of a `value`.'\n  )\n\n  const { node: nearestNode, offset: nearestOffset } = normalizeNodeAndOffset(\n    nativeNode,\n    nativeOffset\n  )\n\n  const window = getWindow(nativeNode)\n  const { parentNode } = nearestNode\n  let rangeNode = parentNode.closest(SELECTORS.LEAF)\n  let offset\n  let node\n\n  // Calculate how far into the text node the `nearestNode` is, so that we can\n  // determine what the offset relative to the text node is.\n  if (rangeNode) {\n    const range = window.document.createRange()\n    const textNode = rangeNode.closest(SELECTORS.TEXT)\n    range.setStart(textNode, 0)\n    range.setEnd(nearestNode, nearestOffset)\n    node = textNode\n\n    // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\n\n    // into \\r\\n. The bug causes a loop when slate-react attempts to reposition\n    // its cursor to match the native position. Use textContent.length instead.\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n    offset = range.cloneContents().textContent.length\n  } else {\n    // For void nodes, the element with the offset key will be a cousin, not an\n    // ancestor, so find it by going down from the nearest void parent.\n    const voidNode = parentNode.closest(SELECTORS.VOID)\n    if (!voidNode) return null\n    rangeNode = voidNode.querySelector(SELECTORS.LEAF)\n    if (!rangeNode) return null\n    node = rangeNode\n    offset = node.textContent.length\n  }\n\n  // COMPAT: If the parent node is a Slate zero-width space, this is because the\n  // text node should have no characters. However, during IME composition the\n  // ASCII characters will be prepended to the zero-width space, so subtract 1\n  // from the offset to account for the zero-width space character.\n  if (\n    offset === node.textContent.length &&\n    parentNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)\n  ) {\n    offset--\n  }\n\n  // Get the string value of the offset key attribute.\n  const offsetKey = rangeNode.getAttribute(DATA_ATTRS.OFFSET_KEY)\n  if (!offsetKey) return null\n\n  const { key } = OffsetKey.parse(offsetKey)\n\n  // COMPAT: If someone is clicking from one Slate editor into another, the\n  // select event fires twice, once for the old editor's `element` first, and\n  // then afterwards for the correct `element`. (2017/03/03)\n  const { value } = editor\n  if (!value.document.hasDescendant(key)) return null\n\n  const point = value.document.createPoint({ key, offset })\n  return point\n}\n\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType === 1 && node.childNodes.length) {\n    const isLast = offset === node.childNodes.length\n    const direction = isLast ? 'backward' : 'forward'\n    const index = isLast ? offset - 1 : offset\n    node = getEditableChild(node, index, direction)\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (node.nodeType === 1 && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, direction)\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return { node, offset }\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\nfunction getEditableChild(parent, index, direction) {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (\n    child.nodeType === 8 ||\n    (child.nodeType === 1 && child.childNodes.length === 0) ||\n    (child.nodeType === 1 && child.getAttribute('contenteditable') === 'false')\n  ) {\n    if (triedForward && triedBackward) break\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    if (direction === 'forward') i++\n    if (direction === 'backward') i--\n  }\n\n  return child || null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findPoint\n","import getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Value } from 'slate'\n\nimport findPoint from './find-point'\n\n/**\n * Find a Slate range from a DOM `native` selection.\n *\n * @param {Selection} native\n * @param {Editor} editor\n * @return {Range}\n */\n\nfunction findRange(native, editor) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findRange(selection)` helper is deprecated in favor of `editor.findRange(selection)`.'\n  )\n\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.'\n  )\n\n  const el = native.anchorNode || native.startContainer\n  if (!el) return null\n\n  const window = getWindow(el)\n\n  // If the `native` object is a DOM `Range` or `StaticRange` object, change it\n  // into something that looks like a DOM `Selection` instead.\n  if (\n    native instanceof window.Range ||\n    (window.StaticRange && native instanceof window.StaticRange)\n  ) {\n    native = {\n      anchorNode: native.startContainer,\n      anchorOffset: native.startOffset,\n      focusNode: native.endContainer,\n      focusOffset: native.endOffset,\n    }\n  }\n\n  const {\n    anchorNode,\n    anchorOffset,\n    focusNode,\n    focusOffset,\n    isCollapsed,\n  } = native\n  const { value } = editor\n  const anchor = findPoint(anchorNode, anchorOffset, editor)\n  const focus = isCollapsed ? anchor : findPoint(focusNode, focusOffset, editor)\n  if (!anchor || !focus) return null\n\n  const { document } = value\n  const range = document.createRange({\n    anchor,\n    focus,\n  })\n\n  return range\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findRange\n","import warning from 'tiny-warning'\nimport { PathUtils } from 'slate'\n\nimport findRange from './find-range'\n\nexport default function getSelectionFromDOM(window, editor, domSelection) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `getSelectionFromDOM(window, editor, domSelection)` helper is deprecated in favor of `editor.findSelection(domSelection)`.'\n  )\n\n  const { value } = editor\n  const { document } = value\n\n  // If there are no ranges, the editor was blurred natively.\n  if (!domSelection.rangeCount) {\n    editor.blur()\n    return\n  }\n\n  // Otherwise, determine the Slate selection from the native one.\n  let range = findRange(domSelection, editor)\n\n  if (!range) {\n    return\n  }\n\n  const { anchor, focus } = range\n  const anchorText = document.getNode(anchor.path)\n  const focusText = document.getNode(focus.path)\n  const anchorInline = document.getClosestInline(anchor.path)\n  const focusInline = document.getClosestInline(focus.path)\n  const focusBlock = document.getClosestBlock(focus.path)\n  const anchorBlock = document.getClosestBlock(anchor.path)\n\n  // COMPAT: If the anchor point is at the start of a non-void, and the\n  // focus point is inside a void node with an offset that isn't `0`, set\n  // the focus offset to `0`. This is due to void nodes <span>'s being\n  // positioned off screen, resulting in the offset always being greater\n  // than `0`. Since we can't know what it really should be, and since an\n  // offset of `0` is less destructive because it creates a hanging\n  // selection, go with `0`. (2017/09/07)\n  if (\n    anchorBlock &&\n    !editor.isVoid(anchorBlock) &&\n    anchor.offset === 0 &&\n    focusBlock &&\n    editor.isVoid(focusBlock) &&\n    focus.offset !== 0\n  ) {\n    range = range.setFocus(focus.setOffset(0))\n  }\n\n  // COMPAT: If the selection is at the end of a non-void inline node, and\n  // there is a node after it, put it in the node after instead. This\n  // standardizes the behavior, since it's indistinguishable to the user.\n  if (\n    anchorInline &&\n    !editor.isVoid(anchorInline) &&\n    anchor.offset === anchorText.text.length\n  ) {\n    const block = document.getClosestBlock(anchor.path)\n    const depth = document.getDepth(block.key)\n    const relativePath = PathUtils.drop(anchor.path, depth)\n    const [next] = block.texts({ path: relativePath })\n\n    if (next) {\n      const [, nextPath] = next\n      const absolutePath = anchor.path.slice(0, depth).concat(nextPath)\n      range = range.moveAnchorTo(absolutePath, 0)\n    }\n  }\n\n  if (\n    focusInline &&\n    !editor.isVoid(focusInline) &&\n    focus.offset === focusText.text.length\n  ) {\n    const block = document.getClosestBlock(focus.path)\n    const depth = document.getDepth(block.key)\n    const relativePath = PathUtils.drop(focus.path, depth)\n    const [next] = block.texts({ path: relativePath })\n\n    if (next) {\n      const [, nextPath] = next\n      const absolutePath = focus.path.slice(0, depth).concat(nextPath)\n      range = range.moveFocusTo(absolutePath, 0)\n    }\n  }\n\n  let selection = document.createSelection(range)\n  selection = selection.setIsFocused(true)\n\n  // Preserve active marks from the current selection.\n  // They will be cleared by `editor.select` if the selection actually moved.\n  selection = selection.set('marks', value.selection.marks)\n\n  return selection\n}\n","/**\n * In Android API 26 and 27 we can tell if the input key was pressed by\n * waiting for the `beforeInput` event and seeing that the last character\n * of its `data` property is char code `10`.\n *\n * Note that at this point it is too late to prevent the event from affecting\n * the DOM so we use other methods to clean the DOM up after we have detected\n * the input.\n *\n * @param  {String} data\n * @return {Boolean}\n */\n\nexport default function isInputDataEnter(data) {\n  if (data == null) return false\n  const lastChar = data[data.length - 1]\n  const charCode = lastChar.charCodeAt(0)\n  return charCode === 10\n}\n","/**\n * In Android sometimes the only way to tell what the user is trying to do\n * is to look at an event's `data` property and see if the last characters\n * matches a character. This method helps us make that determination.\n *\n * @param {String} data\n * @param {[String]} chars\n * @return {Boolean}\n */\n\nexport default function isInputDataLastChar(data, chars) {\n  if (!Array.isArray(chars))\n    throw new Error(`chars must be an array of one character strings`)\n  if (data == null) return false\n  const lastChar = data[data.length - 1]\n  return chars.includes(lastChar)\n}\n","import getWindow from 'get-window'\n\nimport DATA_ATTRS from '../../constants/data-attributes'\n\n/**\n * Is the given node a text node?\n *\n * @param {node} node\n * @param {Window} window\n * @return {Boolean}\n */\n\nfunction isTextNode(node, window) {\n  return node.nodeType === window.Node.TEXT_NODE\n}\n\n/**\n * Takes a node and returns a snapshot of the node.\n *\n * @param {node} node\n * @param {Window} window\n * @return {object} element snapshot\n */\n\nfunction getElementSnapshot(node, window) {\n  const snapshot = {}\n  snapshot.node = node\n\n  if (isTextNode(node, window)) {\n    snapshot.text = node.textContent\n  }\n\n  snapshot.children = Array.from(node.childNodes).map(childNode =>\n    getElementSnapshot(childNode, window)\n  )\n  return snapshot\n}\n\n/**\n * Takes an array of elements and returns a snapshot\n *\n * @param {elements[]} elements\n * @param {Window} window\n * @return {object} snapshot\n */\n\nfunction getSnapshot(elements, window) {\n  if (!elements.length) throw new Error(`elements must be an Array`)\n\n  const lastElement = elements[elements.length - 1]\n  const snapshot = {\n    elements: elements.map(element => getElementSnapshot(element, window)),\n    parent: lastElement.parentElement,\n    next: lastElement.nextElementSibling,\n  }\n  return snapshot\n}\n\n/**\n * Takes an element snapshot and applies it to the element in the DOM.\n * Basically, it fixes the DOM to the point in time that the snapshot was\n * taken. This will put the DOM back in sync with React.\n *\n * @param {Object} snapshot\n * @param {Window} window\n */\n\nfunction applyElementSnapshot(snapshot, window) {\n  const el = snapshot.node\n\n  if (isTextNode(el, window)) {\n    // Update text if it is different\n    if (el.textContent !== snapshot.text) {\n      el.textContent = snapshot.text\n    }\n  }\n\n  snapshot.children.forEach(childSnapshot => {\n    applyElementSnapshot(childSnapshot, window)\n    el.appendChild(childSnapshot.node)\n  })\n\n  // remove children that shouldn't be there\n  const snapLength = snapshot.children.length\n\n  while (el.childNodes.length > snapLength) {\n    el.removeChild(el.childNodes[0])\n  }\n\n  // remove any clones from the DOM. This can happen when a block is split.\n  const { dataset } = el\n  if (!dataset) return // if there's no dataset, don't remove it\n  const key = dataset.key\n  if (!key) return // if there's no `data-key`, don't remove it\n  const dups = new window.Set(\n    Array.from(window.document.querySelectorAll(`[${DATA_ATTRS.KEY}=\"${key}\"]`))\n  )\n  dups.delete(el)\n  dups.forEach(dup => dup.parentElement.removeChild(dup))\n}\n\n/**\n * Takes a snapshot and applies it to the DOM. Rearranges both the contents\n * of the elements in the snapshot as well as putting the elements back into\n * position relative to each other and also makes sure the last element is\n * before the same element as it was when the snapshot was taken.\n *\n * @param {snapshot} snapshot\n * @param {Window} window\n */\n\nfunction applySnapshot(snapshot, window) {\n  const { elements, next, parent } = snapshot\n  elements.forEach(element => applyElementSnapshot(element, window))\n  const lastElement = elements[elements.length - 1].node\n\n  if (snapshot.next) {\n    parent.insertBefore(lastElement, next)\n  } else {\n    parent.appendChild(lastElement)\n  }\n\n  let prevElement = lastElement\n\n  for (let i = elements.length - 2; i >= 0; i--) {\n    const element = elements[i].node\n    parent.insertBefore(element, prevElement)\n    prevElement = element\n  }\n}\n\n/**\n * A snapshot of one or more elements.\n */\n\nexport default class ElementSnapshot {\n  /**\n   * constructor\n   * @param {elements[]} elements - array of element to snapshot. Must be in order.\n   * @param {object} data - any arbitrary data you want to store with the snapshot\n   */\n\n  constructor(elements, data) {\n    this.window = getWindow(elements[0])\n    this.snapshot = getSnapshot(elements, this.window)\n    this.data = data\n  }\n\n  /**\n   * apply the current snapshot to the DOM.\n   */\n\n  apply() {\n    applySnapshot(this.snapshot, this.window)\n  }\n\n  /**\n   * get the data you passed into the constructor.\n   *\n   * @return {object} data\n   */\n\n  getData() {\n    return this.data\n  }\n}\n","import ElementSnapshot from './element-snapshot'\nimport SELECTORS from '../../constants/selectors'\n\n/**\n * Returns the closest element that matches the selector.\n * Unlike the native `Element.closest` method, this doesn't require the\n * starting node to be an Element.\n *\n * @param  {Node} node to start at\n * @param  {String} css selector to match\n * @return {Element} the closest matching element\n */\n\nfunction closest(node, selector, win = window) {\n  if (node.nodeType === win.Node.TEXT_NODE) {\n    node = node.parentNode\n  }\n  return node.closest(selector)\n}\n\n/**\n * A DomSnapshot remembers the state of elements at a given point in time\n * and also remembers the state of the Editor at that time as well.\n * The state can be applied to the DOM at a time in the future.\n */\n\nexport default class DomSnapshot {\n  /**\n   * Constructor.\n   *\n   * @param {Window} window\n   * @param {Editor} editor\n   * @param {Boolean} options.before - should we remember the element before the one passed in\n   */\n\n  constructor(window, editor, { before = false } = {}) {\n    const domSelection = window.getSelection()\n    const { anchorNode } = domSelection\n    const subrootEl = closest(anchorNode, `${SELECTORS.EDITOR} > *`)\n    const elements = [subrootEl]\n\n    // The before option is for when we need to take a snapshot of the current\n    // subroot and the element before when the user hits the backspace key.\n    if (before) {\n      const { previousElementSibling } = subrootEl\n\n      if (previousElementSibling) {\n        elements.unshift(previousElementSibling)\n      }\n    }\n\n    this.snapshot = new ElementSnapshot(elements)\n    this.selection = editor.findSelection(domSelection)\n  }\n\n  /**\n   * Apply the snapshot to the DOM and set the selection in the Editor.\n   *\n   * @param {Editor} editor\n   */\n\n  apply(editor) {\n    const { snapshot, selection } = this\n    snapshot.apply()\n    editor.moveTo(selection.anchor.path, selection.anchor.offset)\n  }\n}\n","/**\n * A function that does nothing\n * @return {Function}\n */\n\nfunction noop() {}\n\n/**\n * Creates an executor like a `resolver` or a `deleter` that handles\n * delayed execution of a method using a `requestAnimationFrame` or `setTimeout`.\n *\n * Unlike a `requestAnimationFrame`, after a method is cancelled, it can be\n * resumed. You can also optionally add a `timeout` after which time the\n * executor is automatically cancelled.\n */\n\nexport default class Executor {\n  /**\n   * Executor\n   * @param {window} window\n   * @param {Function} fn - the function to execute when done\n   * @param {Object} options\n   */\n\n  constructor(window, fn, options = {}) {\n    this.fn = fn\n    this.window = window\n    this.resume()\n    this.onCancel = options.onCancel\n    this.__setTimeout__(options.timeout)\n  }\n\n  __call__ = () => {\n    // I don't clear the timeout since it will be noop'ed anyways. Less code.\n    this.fn()\n    this.preventFurtherCalls() // Ensure you can only call the function once\n  }\n\n  /**\n   * Make sure that the function cannot be executed any more, even if other\n   * methods attempt to call `__call__`.\n   */\n\n  preventFurtherCalls = () => {\n    this.fn = noop\n  }\n\n  /**\n   * Resume the executor's timer, usually after it has been cancelled.\n   *\n   * @param {Number} [ms] - how long to wait by default it is until next frame\n   */\n\n  resume = ms => {\n    // in case resume is called more than once, we don't want old timers\n    // from executing because the `timeoutId` or `callbackId` is overwritten.\n    this.cancel()\n\n    if (ms) {\n      this.mode = 'timeout'\n      this.timeoutId = this.window.setTimeout(this.__call__, ms)\n    } else {\n      this.mode = 'animationFrame'\n      this.callbackId = this.window.requestAnimationFrame(this.__call__)\n    }\n  }\n\n  /**\n   * Cancel the executor from executing after the wait. This can be resumed\n   * with the `resume` method.\n   */\n\n  cancel = () => {\n    if (this.mode === 'timeout') {\n      this.window.clearTimeout(this.timeoutId)\n    } else {\n      this.window.cancelAnimationFrame(this.callbackId)\n    }\n\n    if (this.onCancel) this.onCancel()\n  }\n\n  /**\n   * Sets a timeout after which this executor is automatically cancelled.\n   * @param {Number} ms\n   */\n\n  __setTimeout__ = timeout => {\n    if (timeout == null) return\n\n    this.window.setTimeout(() => {\n      this.cancel()\n      this.preventFurtherCalls()\n    }, timeout)\n  }\n}\n","import Debug from 'debug'\nimport getWindow from 'get-window'\nimport pick from 'lodash/pick'\n\nimport { ANDROID_API_VERSION } from 'slate-dev-environment'\nimport fixSelectionInZeroWidthBlock from './fix-selection-in-zero-width-block'\nimport getSelectionFromDom from '../../utils/get-selection-from-dom'\nimport isInputDataEnter from './is-input-data-enter'\nimport isInputDataLastChar from './is-input-data-last-char'\nimport DomSnapshot from './dom-snapshot'\nimport Executor from './executor'\n\nconst debug = Debug('slate:android')\ndebug.reconcile = Debug('slate:reconcile')\n\ndebug('ANDROID_API_VERSION', { ANDROID_API_VERSION })\n\n/**\n * Define variables related to composition state.\n */\n\nconst NONE = 0\nconst COMPOSING = 1\n\nfunction AndroidPlugin() {\n  /**\n   * The current state of composition.\n   *\n   * @type {NONE|COMPOSING|WAITING}\n   */\n\n  let status = NONE\n\n  /**\n   * The set of nodes that we need to process when we next reconcile.\n   * Usually this is soon after the `onCompositionEnd` event.\n   *\n   * @type {Set} set containing Node objects\n   */\n\n  const nodes = new window.Set()\n\n  /**\n   * Keep a snapshot after a composition end for API 26/27. If a `beforeInput`\n   * gets called with data that ends in an ENTER then we need to use this\n   * snapshot to revert the DOM so that React doesn't get out of sync with the\n   * DOM. We also need to cancel the `reconcile` operation as it interferes in\n   * certain scenarios like hitting 'enter' at the end of a word.\n   *\n   * @type {DomSnapshot} [compositionEndSnapshot]\n\n   */\n\n  let compositionEndSnapshot = null\n\n  /**\n   * When there is a `compositionEnd` we ened to reconcile Slate's Document\n   * with the DOM. The `reconciler` is an instance of `Executor` that does\n   * this for us. It is created on every `compositionEnd` and executes on the\n   * next `requestAnimationFrame`. The `Executor` can be cancelled and resumed\n   * which some methods do.\n   *\n   * @type {Executor}\n   */\n\n  let reconciler = null\n\n  /**\n   * A snapshot that gets taken when there is a `keydown` event in API26/27.\n   * If an `input` gets called with `inputType` of `deleteContentBackward`\n   * we need to undo the delete that Android does to keep React in sync with\n   * the DOM.\n   *\n   * @type {DomSnapshot}\n   */\n\n  let keyDownSnapshot = null\n\n  /**\n   * The deleter is an instace of `Executor` that will execute a delete\n   * operation on the next `requestAnimationFrame`. It has to wait because\n   * we need Android to finish all of its DOM operations to do with deletion\n   * before we revert them to a Snapshot. After reverting, we then execute\n   * Slate's version of delete.\n   *\n   * @type {Executor}\n   */\n\n  let deleter = null\n\n  /**\n   * Because Slate implements its own event handler for `beforeInput` in\n   * addition to React's version, we actually get two. If we cancel the\n   * first native version, the React one will still fire. We set this to\n   * `true` if we don't want that to happen. Remember that when we prevent it,\n   * we need to tell React to `preventDefault` so the event doesn't continue\n   * through React's event system.\n   *\n   * type {Boolean}\n   */\n\n  let preventNextBeforeInput = false\n\n  /**\n   * When a composition ends, in some API versions we may need to know what we\n   * have learned so far about the composition and what we want to do because of\n   * some actions that may come later.\n   *\n   * For example in API 26/27, if we get a `beforeInput` that tells us that the\n   * input was a `.`, then we want the reconcile to happen even if there are\n   * `onInput:delete` events that follow. In this case, we would set\n   * `compositionEndAction` to `period`. During the `onInput` we would check if\n   * the `compositionEndAction` says `period` and if so we would not start the\n   * `delete` action.\n   *\n   * @type {(String|null)}\n   */\n\n  let compositionEndAction = null\n\n  /**\n   * Looks at the `nodes` we have collected, usually the things we have edited\n   * during the course of a composition, and then updates Slate's internal\n   * Document based on the text values in these DOM nodes and also updates\n   * Slate's Selection based on the current cursor position in the Editor.\n   *\n   * @param {Window} window\n   * @param {Editor} editor\n   * @param {String} options.from - where reconcile was called from for debug\n   */\n\n  function reconcile(window, editor, { from }) {\n    debug.reconcile({ from })\n    const domSelection = window.getSelection()\n    const selection = editor.findSelection(domSelection)\n\n    nodes.forEach(node => {\n      editor.reconcileDOMNode(node)\n    })\n\n    editor.select(selection)\n    nodes.clear()\n  }\n\n  /**\n   * On before input.\n   *\n   * Check `components/content` because some versions of Android attach a\n   * native `beforeinput` event on the Editor. In this case, you might need\n   * to distinguish whether the event coming through is the native or React\n   * version of the event. Also, if you cancel the native version that does\n   * not necessarily mean that the React version is cancelled.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    const isNative = !event.nativeEvent\n\n    debug('onBeforeInput', {\n      isNative,\n      event,\n      status,\n      e: pick(event, ['data', 'inputType', 'isComposing', 'nativeEvent']),\n    })\n\n    const window = getWindow(event.target)\n\n    if (preventNextBeforeInput) {\n      event.preventDefault()\n      preventNextBeforeInput = false\n      return\n    }\n\n    switch (ANDROID_API_VERSION) {\n      case 25:\n        // prevent onBeforeInput to allow selecting an alternate suggest to\n        // work.\n        break\n      case 26:\n      case 27:\n        if (deleter) {\n          deleter.cancel()\n          reconciler.resume()\n        }\n\n        // This analyses Android's native `beforeInput` which Slate adds\n        // on in the `Content` component. It only fires if the cursor is at\n        // the end of a block. Otherwise, the code below checks.\n        if (isNative) {\n          if (\n            event.inputType === 'insertParagraph' ||\n            event.inputType === 'insertLineBreak'\n          ) {\n            debug('onBeforeInput:enter:native', {})\n            const domSelection = window.getSelection()\n            const selection = getSelectionFromDom(window, editor, domSelection)\n            preventNextBeforeInput = true\n            event.preventDefault()\n            editor.moveTo(selection.anchor.path, selection.anchor.offset)\n            editor.splitBlock()\n          }\n        } else {\n          if (isInputDataLastChar(event.data, ['.'])) {\n            debug('onBeforeInput:period')\n            reconciler.cancel()\n            compositionEndAction = 'period'\n            return\n          }\n\n          // This looks at the beforeInput event's data property and sees if it\n          // ends in a linefeed which is character code 10. This appears to be\n          // the only way to detect that enter has been pressed except at end\n          // of line where it doesn't work.\n          const isEnter = isInputDataEnter(event.data)\n\n          if (isEnter) {\n            if (reconciler) reconciler.cancel()\n\n            window.requestAnimationFrame(() => {\n              debug('onBeforeInput:enter:react', {})\n              compositionEndSnapshot.apply(editor)\n              editor.splitBlock()\n            })\n          }\n        }\n\n        break\n      case 28:\n        // If a `beforeInput` event fires after an `input:deleteContentBackward`\n        // event, it appears to be a good indicator that it is some sort of\n        // special combined Android event. If this is the case, then we don't\n        // want to have a deletion to happen, we just want to wait until Android\n        // has done its thing and then at the end we just want to reconcile.\n        if (deleter) {\n          deleter.cancel()\n          reconciler.resume()\n        }\n\n        break\n      default:\n        if (status !== COMPOSING) next()\n    }\n  }\n\n  /**\n   * On Composition end. By default, when a `compositionEnd` event happens,\n   * we start a reconciler. The reconciler will update Slate's Document using\n   * the DOM as the source of truth. In some cases, the reconciler needs to\n   * be cancelled and can also be resumed. For example, when a delete\n   * immediately followed a `compositionEnd`, we don't want to reconcile.\n   * Instead, we want the `delete` to take precedence.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n  function onCompositionEnd(event, editor, next) {\n    debug('onCompositionEnd', { event })\n    const window = getWindow(event.target)\n    const domSelection = window.getSelection()\n    const { anchorNode } = domSelection\n\n    switch (ANDROID_API_VERSION) {\n      case 26:\n      case 27:\n        compositionEndSnapshot = new DomSnapshot(window, editor)\n        // fixes a bug in Android API 26 & 27 where a `compositionEnd` is triggered\n        // without the corresponding `compositionStart` event when clicking a\n        // suggestion.\n        //\n        // If we don't add this, the `onBeforeInput` is triggered and passes\n        // through to the `before` plugin.\n        status = COMPOSING\n        break\n    }\n\n    compositionEndAction = 'reconcile'\n    nodes.add(anchorNode)\n\n    reconciler = new Executor(window, () => {\n      status = NONE\n      reconcile(window, editor, { from: 'onCompositionEnd:reconciler' })\n      compositionEndAction = null\n    })\n  }\n\n  /**\n   * On composition start.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n  function onCompositionStart(event, editor, next) {\n    debug('onCompositionStart', { event })\n    status = COMPOSING\n    nodes.clear()\n  }\n\n  /**\n   * On composition update.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n  function onCompositionUpdate(event, editor, next) {\n    debug('onCompositionUpdate', { event })\n  }\n\n  /**\n   * On input.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n  function onInput(event, editor, next) {\n    debug('onInput', {\n      event,\n      status,\n      e: pick(event, ['data', 'nativeEvent', 'inputType', 'isComposing']),\n    })\n\n    switch (ANDROID_API_VERSION) {\n      case 24:\n      case 25:\n        break\n      case 26:\n      case 27:\n      case 28:\n        const { nativeEvent } = event\n\n        if (ANDROID_API_VERSION === 28) {\n          // NOTE API 28:\n          // When a user hits space and then backspace in `middle` we end up\n          // with `midle`.\n          //\n          // This is because when the user hits space, the composition is not\n          // ended because `compositionEnd` is not called yet. When backspace is\n          // hit, the `compositionEnd` is called. We need to revert the DOM but\n          // the reconciler has not had a chance to run from the\n          // `compositionEnd` because it is set to run on the next\n          // `requestAnimationFrame`. When the backspace is carried out on the\n          // Slate Value, Slate doesn't know about the space yet so the\n          // backspace is carried out without the space cuasing us to lose a\n          // character.\n          //\n          // This fix forces Android to reconcile immediately after hitting\n          // the space.\n          //\n          // NOTE API 27:\n          // It is confirmed that this bug does not present itself on API27.\n          // A space fires a `compositionEnd` (as well as other events including\n          // an input that is a delete) so the reconciliation happens.\n          //\n          if (\n            nativeEvent.inputType === 'insertText' &&\n            nativeEvent.data === ' '\n          ) {\n            if (reconciler) reconciler.cancel()\n            if (deleter) deleter.cancel()\n            reconcile(window, editor, { from: 'onInput:space' })\n            return\n          }\n        }\n\n        if (ANDROID_API_VERSION === 26 || ANDROID_API_VERSION === 27) {\n          if (compositionEndAction === 'period') {\n            debug('onInput:period:abort')\n            // This means that there was a `beforeInput` that indicated the\n            // period was pressed. When a period is pressed, you get a bunch\n            // of delete actions mixed in. We want to ignore those. At this\n            // point, we add the current node to the list of things we need to\n            // resolve at the next compositionEnd. We know that a new\n            // composition will start right after this event so it is safe to\n            // do this.\n            const { anchorNode } = window.getSelection()\n            nodes.add(anchorNode)\n            return\n          }\n        }\n\n        if (nativeEvent.inputType === 'deleteContentBackward') {\n          debug('onInput:delete', { keyDownSnapshot })\n          const window = getWindow(event.target)\n          if (reconciler) reconciler.cancel()\n          if (deleter) deleter.cancel()\n\n          deleter = new Executor(\n            window,\n            () => {\n              debug('onInput:delete:callback', { keyDownSnapshot })\n              keyDownSnapshot.apply(editor)\n              editor.deleteBackward()\n              deleter = null\n            },\n            {\n              onCancel() {\n                deleter = null\n              },\n            }\n          )\n          return\n        }\n\n        if (status === COMPOSING) {\n          const { anchorNode } = window.getSelection()\n          nodes.add(anchorNode)\n          return\n        }\n\n        // Some keys like '.' are input without compositions. This happens\n        // in API28. It might be happening in API 27 as well. Check by typing\n        // `It me. No.` On a blank line.\n        if (ANDROID_API_VERSION === 28) {\n          debug('onInput:fallback')\n          const { anchorNode } = window.getSelection()\n          nodes.add(anchorNode)\n\n          window.requestAnimationFrame(() => {\n            debug('onInput:fallback:callback')\n            reconcile(window, editor, { from: 'onInput:fallback' })\n          })\n          return\n        }\n\n        break\n      default:\n        if (status === COMPOSING) return\n        next()\n    }\n  }\n\n  /**\n   * On key down.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n  function onKeyDown(event, editor, next) {\n    debug('onKeyDown', {\n      event,\n      status,\n      e: pick(event, [\n        'char',\n        'charCode',\n        'code',\n        'key',\n        'keyCode',\n        'keyIdentifier',\n        'keyLocation',\n        'location',\n        'nativeEvent',\n        'which',\n      ]),\n    })\n\n    const window = getWindow(event.target)\n\n    switch (ANDROID_API_VERSION) {\n      // 1. We want to allow enter keydown to allows go through\n      // 2. We want to deny keydown, I think, when it fires before the composition\n      //    or something. Need to remember what it was.\n\n      case 25:\n        // in API25 prevent other keys to fix clicking a word and then\n        // selecting an alternate suggestion.\n        //\n        // NOTE:\n        // The `setSelectionFromDom` is to allow hitting `Enter` to work\n        // because the selection needs to be in the right place; however,\n        // for now we've removed the cancelling of `onSelect` and everything\n        // appears to be working. Not sure why we removed `onSelect` though\n        // in API25.\n        if (event.key === 'Enter') {\n          // const window = getWindow(event.target)\n          // const selection = window.getSelection()\n          // setSelectionFromDom(window, editor, selection)\n          next()\n        }\n\n        break\n      case 26:\n      case 27:\n        if (event.key === 'Enter') {\n          debug('onKeyDown:enter', {})\n\n          if (deleter) {\n            // If a `deleter` exists which means there was an onInput with\n            // `deleteContentBackward` that hasn't fired yet, then we know\n            // this is one of the cases where we have to revert to before\n            // the split.\n            deleter.cancel()\n            event.preventDefault()\n\n            window.requestAnimationFrame(() => {\n              debug('onKeyDown:enter:callback')\n              compositionEndSnapshot.apply(editor)\n              editor.splitBlock()\n            })\n          } else {\n            event.preventDefault()\n            // If there is no deleter, all we have to do is prevent the\n            // action before applying or splitBlock. In this scenario, we\n            // have to grab the selection from the DOM.\n            const domSelection = window.getSelection()\n            const selection = getSelectionFromDom(window, editor, domSelection)\n            editor.moveTo(selection.anchor.path, selection.anchor.offset)\n            editor.splitBlock()\n          }\n          return\n        }\n\n        // We need to take a snapshot of the current selection and the\n        // element before when the user hits the backspace key. This is because\n        // we only know if the user hit backspace if the `onInput` event that\n        // follows has an `inputType` of `deleteContentBackward`. At that time\n        // it's too late to stop the event.\n        keyDownSnapshot = new DomSnapshot(window, editor, {\n          before: true,\n        })\n\n        // If we let 'Enter' through it breaks handling of hitting\n        // enter at the beginning of a word so we need to stop it.\n        break\n      case 28:\n        {\n          if (event.key === 'Enter') {\n            debug('onKeyDown:enter')\n            event.preventDefault()\n            if (reconciler) reconciler.cancel()\n            if (deleter) deleter.cancel()\n\n            window.requestAnimationFrame(() => {\n              reconcile(window, editor, { from: 'onKeyDown:enter' })\n              editor.splitBlock()\n            })\n            return\n          }\n\n          // We need to take a snapshot of the current selection and the\n          // element before when the user hits the backspace key. This is because\n          // we only know if the user hit backspace if the `onInput` event that\n          // follows has an `inputType` of `deleteContentBackward`. At that time\n          // it's too late to stop the event.\n          keyDownSnapshot = new DomSnapshot(window, editor, {\n            before: true,\n          })\n\n          debug('onKeyDown:snapshot', { keyDownSnapshot })\n        }\n\n        // If we let 'Enter' through it breaks handling of hitting\n        // enter at the beginning of a word so we need to stop it.\n        break\n\n      default:\n        if (status !== COMPOSING) {\n          next()\n        }\n    }\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onSelect(event, editor, next) {\n    debug('onSelect', { event, status })\n\n    switch (ANDROID_API_VERSION) {\n      // We don't want to have the selection move around in an onSelect because\n      // it happens after we press `enter` in the same transaction. This\n      // causes the cursor position to not be properly placed.\n      case 26:\n      case 27:\n      case 28:\n        const window = getWindow(event.target)\n        fixSelectionInZeroWidthBlock(window)\n        break\n      default:\n        break\n    }\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput,\n    onCompositionEnd,\n    onCompositionStart,\n    onCompositionUpdate,\n    onInput,\n    onKeyDown,\n    onSelect,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default AndroidPlugin\n","/**\n * The transfer types that Slate recognizes.\n *\n * @type {Object}\n */\n\nexport default {\n  FRAGMENT: 'application/x-slate-fragment',\n  HTML: 'text/html',\n  NODE: 'application/x-slate-node',\n  RICH: 'text/rtf',\n  TEXT: 'text/plain',\n}\n","import { Node } from 'slate'\nimport warning from 'tiny-warning'\n\nimport DATA_ATTRS from '../constants/data-attributes'\n\n/**\n * Find the DOM node for a `key`.\n *\n * @param {String|Node} key\n * @param {Window} win (optional)\n * @return {Element}\n */\n\nfunction findDOMNode(key, win = window) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findDOMNode(key)` helper is deprecated in favor of `editor.findDOMNode(path)`.'\n  )\n\n  if (Node.isNode(key)) {\n    key = key.key\n  }\n\n  const el = win.document.querySelector(`[${DATA_ATTRS.KEY}=\"${key}\"]`)\n\n  if (!el) {\n    throw new Error(\n      `Unable to find a DOM node for \"${key}\". This is often because of forgetting to add \\`props.attributes\\` to a custom component.`\n    )\n  }\n\n  return el\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMNode\n","import Base64 from 'slate-base64-serializer'\nimport Plain from 'slate-plain-serializer'\nimport getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport { IS_IE } from 'slate-dev-environment'\nimport { Value } from 'slate'\n\nimport TRANSFER_TYPES from '../constants/transfer-types'\nimport removeAllRanges from './remove-all-ranges'\nimport findDOMNode from './find-dom-node'\nimport DATA_ATTRS from '../constants/data-attributes'\nimport SELECTORS from '../constants/selectors'\n\nconst { FRAGMENT, HTML, TEXT } = TRANSFER_TYPES\n\n/**\n * Prepares a Slate document fragment to be copied to the clipboard.\n *\n * @param {Event} event\n * @param {Editor} editor\n */\n\nfunction cloneFragment(event, editor, callback = () => undefined) {\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `cloneFragment` utility takes an `editor` instead of a `value`.'\n  )\n\n  const window = getWindow(event.target)\n  const native = window.getSelection()\n  const { value } = editor\n  const { document, fragment, selection } = value\n  const { start, end } = selection\n  const startVoid = document.getClosestVoid(start.path, editor)\n  const endVoid = document.getClosestVoid(end.path, editor)\n\n  // If the selection is collapsed, and it isn't inside a void node, abort.\n  if (native.isCollapsed && !startVoid) return\n\n  // Create a fake selection so that we can add a Base64-encoded copy of the\n  // fragment to the HTML, to decode on future pastes.\n  const encoded = Base64.serializeNode(fragment)\n  const range = native.getRangeAt(0)\n  let contents = range.cloneContents()\n  let attach = contents.childNodes[0]\n\n  // Make sure attach is a non-empty node, since empty nodes will not get copied\n  contents.childNodes.forEach(node => {\n    if (node.textContent && node.textContent.trim() !== '') {\n      attach = node\n    }\n  })\n\n  // COMPAT: If the end node is a void node, we need to move the end of the\n  // range from the void node's spacer span, to the end of the void node's\n  // content, since the spacer is before void's content in the DOM.\n  if (endVoid) {\n    const r = range.cloneRange()\n    const node = findDOMNode(endVoid, window)\n    r.setEndAfter(node)\n    contents = r.cloneContents()\n  }\n\n  // COMPAT: If the start node is a void node, we need to attach the encoded\n  // fragment to the void node's content node instead of the spacer, because\n  // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n  // most browsers. (2018/04/27)\n  if (startVoid) {\n    attach = contents.childNodes[0].childNodes[1].firstChild\n  }\n\n  // Remove any zero-width space spans from the cloned DOM so that they don't\n  // show up elsewhere when pasted.\n  ;[].slice\n    .call(contents.querySelectorAll(SELECTORS.ZERO_WIDTH))\n    .forEach(zw => {\n      const isNewline = zw.getAttribute(DATA_ATTRS.ZERO_WIDTH) === 'n'\n      zw.textContent = isNewline ? '\\n' : ''\n    })\n\n  // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n  // in the HTML, and can be used for intra-Slate pasting. If it's a text\n  // node, wrap it in a `<span>` so we have something to set an attribute on.\n  if (attach.nodeType === 3) {\n    const span = window.document.createElement('span')\n\n    // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n    // then leading and trailing spaces will be ignored. (2017/09/21)\n    span.style.whiteSpace = 'pre'\n\n    span.appendChild(attach)\n    contents.appendChild(span)\n    attach = span\n  }\n\n  attach.setAttribute(DATA_ATTRS.FRAGMENT, encoded)\n\n  //  Creates value from only the selected blocks\n  //  Then gets plaintext for clipboard with proper linebreaks for BLOCK elements\n  //  Via Plain serializer\n  const valFromSelection = Value.create({ document: fragment })\n  const plainText = Plain.serialize(valFromSelection)\n\n  // Add the phony content to a div element. This is needed to copy the\n  // contents into the html clipboard register.\n  const div = window.document.createElement('div')\n  div.appendChild(contents)\n\n  // For browsers supporting it, we set the clipboard registers manually,\n  // since the result is more predictable.\n  // COMPAT: IE supports the setData method, but only in restricted sense.\n  // IE doesn't support arbitrary MIME types or common ones like 'text/plain';\n  // it only accepts \"Text\" (which gets mapped to 'text/plain') and \"Url\"\n  // (mapped to 'text/url-list'); so, we should only enter block if !IS_IE\n  if (event.clipboardData && event.clipboardData.setData && !IS_IE) {\n    event.preventDefault()\n    event.clipboardData.setData(TEXT, plainText)\n    event.clipboardData.setData(FRAGMENT, encoded)\n    event.clipboardData.setData(HTML, div.innerHTML)\n    callback()\n    return\n  }\n\n  // COMPAT: For browser that don't support the Clipboard API's setData method,\n  // we must rely on the browser to natively copy what's selected.\n  // So we add the div (containing our content) to the DOM, and select it.\n  const editorEl = event.target.closest(SELECTORS.EDITOR)\n  div.setAttribute('contenteditable', true)\n  div.style.position = 'absolute'\n  div.style.left = '-9999px'\n  editorEl.appendChild(div)\n  native.selectAllChildren(div)\n\n  // Revert to the previous selection right after copying.\n  window.requestAnimationFrame(() => {\n    editorEl.removeChild(div)\n    removeAllRanges(native)\n    native.addRange(range)\n    callback()\n  })\n}\n\nexport default cloneFragment\n","import Base64 from 'slate-base64-serializer'\nimport { IS_IE } from 'slate-dev-environment'\n\nimport TRANSFER_TYPES from '../constants/transfer-types'\nimport DATA_ATTRS from '../constants/data-attributes'\n\n/**\n * Transfer types.\n *\n * @type {String}\n */\n\nconst { FRAGMENT, HTML, NODE, RICH, TEXT } = TRANSFER_TYPES\n\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nconst FRAGMENT_MATCHER = / data-slate-fragment=\"([^\\s\"]+)\"/\n\n/**\n * Get the transfer data from an `event`.\n *\n * @param {Event} event\n * @return {Object}\n */\n\nfunction getEventTransfer(event) {\n  // COMPAT: IE 11 doesn't populate nativeEvent with either\n  // dataTransfer or clipboardData. We'll need to use the base event\n  // object (2018/14/6)\n  if (!IS_IE && event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const transfer = event.dataTransfer || event.clipboardData\n  let fragment = getType(transfer, FRAGMENT)\n  let node = getType(transfer, NODE)\n  const html = getType(transfer, HTML)\n  const rich = getType(transfer, RICH)\n  let text = getType(transfer, TEXT)\n  let files\n\n  // If there isn't a fragment, but there is HTML, check to see if the HTML is\n  // actually an encoded fragment.\n  if (!fragment && html && ~html.indexOf(` ${DATA_ATTRS.FRAGMENT}=\"`)) {\n    const matches = FRAGMENT_MATCHER.exec(html)\n    const [full, encoded] = matches // eslint-disable-line no-unused-vars\n    if (encoded) fragment = encoded\n  }\n\n  // COMPAT: Edge doesn't handle custom data types\n  // These will be embedded in text/plain in this case (2017/7/12)\n  if (text) {\n    const embeddedTypes = getEmbeddedTypes(text)\n\n    if (embeddedTypes[FRAGMENT]) fragment = embeddedTypes[FRAGMENT]\n    if (embeddedTypes[NODE]) node = embeddedTypes[NODE]\n    if (embeddedTypes[TEXT]) text = embeddedTypes[TEXT]\n  }\n\n  // Decode a fragment or node if they exist.\n  if (fragment) fragment = Base64.deserializeNode(fragment)\n  if (node) node = Base64.deserializeNode(node)\n\n  // COMPAT: Edge sometimes throws 'NotSupportedError'\n  // when accessing `transfer.items` (2017/7/12)\n  try {\n    // Get and normalize files if they exist.\n    if (transfer.items && transfer.items.length) {\n      files = Array.from(transfer.items)\n        .map(item => (item.kind === 'file' ? item.getAsFile() : null))\n        .filter(exists => exists)\n    } else if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files)\n    }\n  } catch (err) {\n    if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files)\n    }\n  }\n\n  // Determine the type of the data.\n  const data = { files, fragment, html, node, rich, text }\n  data.type = getTransferType(data)\n  return data\n}\n\n/**\n * Takes text input, checks whether contains embedded data\n * and returns object with original text +/- additional data\n *\n * @param {String} text\n * @return {Object}\n */\n\nfunction getEmbeddedTypes(text) {\n  const prefix = 'SLATE-DATA-EMBED::'\n\n  if (text.substring(0, prefix.length) !== prefix) {\n    return { TEXT: text }\n  }\n\n  // Attempt to parse, if fails then just standard text/plain\n  // Otherwise, already had data embedded\n  try {\n    return JSON.parse(text.substring(prefix.length))\n  } catch (err) {\n    throw new Error('Unable to parse custom Slate drag event data.')\n  }\n}\n\n/**\n * Get the type of a transfer from its `data`.\n *\n * @param {Object} data\n * @return {String}\n */\n\nfunction getTransferType(data) {\n  if (data.fragment) return 'fragment'\n  if (data.node) return 'node'\n\n  // COMPAT: Microsoft Word adds an image of the selected text to the data.\n  // Since files are preferred over HTML or text, this would cause the type to\n  // be considered `files`. But it also adds rich text data so we can check\n  // for that and properly set the type to `html` or `text`. (2016/11/21)\n  if (data.rich && data.html) return 'html'\n  if (data.rich && data.text) return 'text'\n\n  if (data.files && data.files.length) return 'files'\n  if (data.html) return 'html'\n  if (data.text) return 'text'\n  return 'unknown'\n}\n\n/**\n * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or\n * `text/plain` from transfers's `data` if possible, otherwise return null.\n *\n * @param {Object} transfer\n * @param {String} type\n * @return {String}\n */\n\nfunction getType(transfer, type) {\n  if (!transfer.types || !transfer.types.length) {\n    // COMPAT: In IE 11, there is no `types` field but `getData('Text')`\n    // is supported`. (2017/06/23)\n    return type === TEXT ? transfer.getData('Text') || null : null\n  }\n\n  // COMPAT: In Edge, transfer.types doesn't respond to `indexOf`. (2017/10/25)\n  const types = Array.from(transfer.types)\n\n  return types.indexOf(type) !== -1 ? transfer.getData(type) || null : null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getEventTransfer\n","import TRANSFER_TYPES from '../constants/transfer-types'\n\n/**\n * The default plain text transfer type.\n *\n * @type {String}\n */\n\nconst { TEXT } = TRANSFER_TYPES\n\n/**\n * Set data with `type` and `content` on an `event`.\n *\n * COMPAT: In Edge, custom types throw errors, so embed all non-standard\n * types in text/plain compound object. (2017/7/12)\n *\n * @param {Event} event\n * @param {String} type\n * @param {String} content\n */\n\nfunction setEventTransfer(event, type, content) {\n  const mime = TRANSFER_TYPES[type.toUpperCase()]\n\n  if (!mime) {\n    throw new Error(`Cannot set unknown transfer type \"${mime}\".`)\n  }\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const transfer = event.dataTransfer || event.clipboardData\n\n  try {\n    transfer.setData(mime, content)\n    // COMPAT: Safari needs to have the 'text' (and not 'text/plain') value in dataTransfer\n    // to display the cursor while dragging internally.\n    transfer.setData('text', transfer.getData('text'))\n  } catch (err) {\n    const prefix = 'SLATE-DATA-EMBED::'\n    const text = transfer.getData(TEXT)\n    let obj = {}\n\n    // If the existing plain text data is prefixed, it's Slate JSON data.\n    if (text.substring(0, prefix.length) === prefix) {\n      try {\n        obj = JSON.parse(text.substring(prefix.length))\n      } catch (e) {\n        throw new Error(\n          'Failed to parse Slate data from `DataTransfer` object.'\n        )\n      }\n    } else {\n      // Otherwise, it's just set it as is.\n      obj[TEXT] = text\n    }\n\n    obj[mime] = content\n    const string = `${prefix}${JSON.stringify(obj)}`\n    transfer.setData(TEXT, string)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default setEventTransfer\n","import Base64 from 'slate-base64-serializer'\nimport Debug from 'debug'\nimport Hotkeys from 'slate-hotkeys'\nimport Plain from 'slate-plain-serializer'\nimport getWindow from 'get-window'\nimport { IS_IOS, IS_IE, IS_EDGE } from 'slate-dev-environment'\n\nimport cloneFragment from '../../utils/clone-fragment'\nimport getEventTransfer from '../../utils/get-event-transfer'\nimport setEventTransfer from '../../utils/set-event-transfer'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:after')\n\n/**\n * A plugin that adds the \"after\" browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction AfterPlugin(options = {}) {\n  let isDraggingInternally = null\n  let isMouseDown = false\n\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    const { value } = editor\n    const isSynthetic = !!event.nativeEvent\n\n    // If the event is synthetic, it's React's polyfill of `beforeinput` that\n    // isn't a true `beforeinput` event with meaningful information. It only\n    // gets triggered for character insertions, so we can just insert directly.\n    if (isSynthetic) {\n      event.preventDefault()\n      editor.insertText(event.data)\n      return next()\n    }\n\n    // Otherwise, we can use the information in the `beforeinput` event to\n    // figure out the exact change that will occur, and prevent it.\n    const [targetRange] = event.getTargetRanges()\n    if (!targetRange) return next()\n\n    debug('onBeforeInput', { event })\n\n    event.preventDefault()\n\n    const { document, selection } = value\n    const range = editor.findRange(targetRange)\n\n    switch (event.inputType) {\n      case 'deleteByDrag':\n      case 'deleteByCut':\n      case 'deleteContent':\n      case 'deleteContentBackward':\n      case 'deleteContentForward': {\n        editor.deleteAtRange(range)\n        break\n      }\n\n      case 'deleteWordBackward': {\n        editor.deleteWordBackwardAtRange(range)\n        break\n      }\n\n      case 'deleteWordForward': {\n        editor.deleteWordForwardAtRange(range)\n        break\n      }\n\n      case 'deleteSoftLineBackward':\n      case 'deleteHardLineBackward': {\n        editor.deleteLineBackwardAtRange(range)\n        break\n      }\n\n      case 'deleteSoftLineForward':\n      case 'deleteHardLineForward': {\n        editor.deleteLineForwardAtRange(range)\n        break\n      }\n\n      case 'insertLineBreak':\n      case 'insertParagraph': {\n        const hasVoidParent = document.hasVoidParent(\n          selection.start.path,\n          editor\n        )\n\n        if (hasVoidParent) {\n          editor.moveToStartOfNextText()\n        } else {\n          editor.splitBlockAtRange(range)\n        }\n\n        break\n      }\n\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText': {\n        // COMPAT: `data` should have the text for the `insertText` input type\n        // and `dataTransfer` should have the text for the\n        // `insertReplacementText` input type, but Safari uses `insertText` for\n        // spell check replacements and sets `data` to `null`. (2018/08/09)\n        const text =\n          event.data == null\n            ? event.dataTransfer.getData('text/plain')\n            : event.data\n\n        if (text == null) break\n\n        editor.insertTextAtRange(range, text, selection.marks)\n\n        // If the text was successfully inserted, and the selection had marks\n        // on it, unset the selection's marks.\n        if (selection.marks && value.document !== editor.value.document) {\n          editor.select({ marks: null })\n        }\n\n        break\n      }\n    }\n\n    next()\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBlur(event, editor, next) {\n    debug('onBlur', { event })\n    editor.blur()\n    next()\n  }\n\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onClick(event, editor, next) {\n    if (editor.readOnly) return next()\n\n    const { value } = editor\n    const { document } = value\n    const path = editor.findPath(event.target)\n    if (!path) return next()\n\n    debug('onClick', { event })\n\n    const node = document.getNode(path)\n    const ancestors = document.getAncestors(path)\n    const isVoid =\n      node && (editor.isVoid(node) || ancestors.some(a => editor.isVoid(a)))\n\n    if (isVoid) {\n      // COMPAT: In Chrome & Safari, selections that are at the zero offset of\n      // an inline node will be automatically replaced to be at the last offset\n      // of a previous inline node, which screws us up, so we always want to set\n      // it to the end of the node. (2016/11/29)\n      editor.focus().moveToEndOfNode(node)\n    }\n\n    next()\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCopy(event, editor, next) {\n    debug('onCopy', { event })\n    cloneFragment(event, editor)\n    next()\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCut(event, editor, next) {\n    debug('onCut', { event })\n\n    // Once the fake cut content has successfully been added to the clipboard,\n    // delete the content in the current selection.\n    cloneFragment(event, editor, () => {\n      // If user cuts a void block node or a void inline node,\n      // manually removes it since selection is collapsed in this case.\n      const { value } = editor\n      const { document, selection } = value\n      const { end, isCollapsed } = selection\n      let voidPath\n\n      if (isCollapsed) {\n        for (const [node, path] of document.ancestors(end.path)) {\n          if (editor.isVoid(node)) {\n            voidPath = path\n            break\n          }\n        }\n      }\n\n      if (voidPath) {\n        editor.removeNodeByKey(voidPath)\n      } else {\n        editor.delete()\n      }\n    })\n\n    next()\n  }\n\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnd(event, editor, next) {\n    debug('onDragEnd', { event })\n    isDraggingInternally = null\n    next()\n  }\n\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragStart(event, editor, next) {\n    debug('onDragStart', { event })\n\n    isDraggingInternally = true\n\n    const { value } = editor\n    const { document } = value\n    const path = editor.findPath(event.target)\n    const node = document.getNode(path)\n    const ancestors = document.getAncestors(path)\n    const isVoid =\n      node && (editor.isVoid(node) || ancestors.some(a => editor.isVoid(a)))\n    const selectionIncludesNode = value.blocks.some(block => block === node)\n\n    // If a void block is dragged and is not selected, select it (necessary for local drags).\n    if (isVoid && !selectionIncludesNode) {\n      editor.moveToRangeOfNode(node)\n    }\n\n    const fragment = editor.value.fragment\n    const encoded = Base64.serializeNode(fragment)\n    setEventTransfer(event, 'fragment', encoded)\n    next()\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDrop(event, editor, next) {\n    const { value } = editor\n    const { document, selection } = value\n    const window = getWindow(event.target)\n    let target = editor.findEventRange(event)\n\n    if (!target) {\n      return next()\n    }\n\n    debug('onDrop', { event })\n\n    const transfer = getEventTransfer(event)\n    const { type, fragment, text } = transfer\n\n    editor.focus()\n\n    // If the drag is internal and the target is after the selection, it\n    // needs to account for the selection's content being deleted.\n    if (\n      isDraggingInternally &&\n      selection.end.offset < target.end.offset &&\n      selection.end.path.equals(target.end.path)\n    ) {\n      target = target.moveForward(\n        selection.start.path.equals(selection.end.path)\n          ? 0 - selection.end.offset + selection.start.offset\n          : 0 - selection.end.offset\n      )\n    }\n\n    if (isDraggingInternally) {\n      editor.delete()\n    }\n\n    editor.select(target)\n\n    if (type === 'text' || type === 'html') {\n      const { anchor } = target\n      let hasVoidParent = document.hasVoidParent(anchor.path, editor)\n\n      if (hasVoidParent) {\n        let p = anchor.path\n        let n = document.getNode(anchor.path)\n\n        while (hasVoidParent) {\n          const [nxt] = document.texts({ path: p })\n\n          if (!nxt) {\n            break\n          }\n\n          ;[n, p] = nxt\n          hasVoidParent = document.hasVoidParent(p, editor)\n        }\n\n        if (n) editor.moveToStartOfNode(n)\n      }\n\n      if (text) {\n        text.split('\\n').forEach((line, i) => {\n          if (i > 0) editor.splitBlock()\n          editor.insertText(line)\n        })\n      }\n    }\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment)\n    }\n\n    // COMPAT: React's onSelect event breaks after an onDrop event\n    // has fired in a node: https://github.com/facebook/react/issues/11379.\n    // Until this is fixed in React, we dispatch a mouseup event on that\n    // DOM node, since that will make it go back to normal.\n    const el = editor.findDOMNode(target.focus.path)\n\n    if (el) {\n      el.dispatchEvent(\n        new MouseEvent('mouseup', {\n          view: window,\n          bubbles: true,\n          cancelable: true,\n        })\n      )\n    }\n\n    next()\n  }\n\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onFocus(event, editor, next) {\n    debug('onFocus', { event })\n\n    // COMPAT: If the focus event is a mouse-based one, it will be shortly\n    // followed by a `selectionchange`, so we need to deselect here to prevent\n    // the old selection from being set by the `updateSelection` of `<Content>`,\n    // preventing the `selectionchange` from firing. (2018/11/07)\n    if (isMouseDown && !IS_IE && !IS_EDGE) {\n      editor.deselect().focus()\n    } else {\n      editor.focus()\n    }\n\n    next()\n  }\n\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onInput(event, editor, next) {\n    debug('onInput')\n\n    const window = getWindow(event.target)\n    const domSelection = window.getSelection()\n    const selection = editor.findSelection(domSelection)\n\n    if (selection) {\n      editor.select(selection)\n    } else {\n      editor.blur()\n    }\n\n    const { anchorNode } = domSelection\n    editor.reconcileDOMNode(anchorNode)\n\n    next()\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onKeyDown(event, editor, next) {\n    debug('onKeyDown', { event })\n\n    const { value } = editor\n    const { document, selection } = value\n    const { start } = selection\n    const hasVoidParent = document.hasVoidParent(start.path, editor)\n\n    // COMPAT: In iOS, some of these hotkeys are handled in the\n    // `onNativeBeforeInput` handler of the `<Content>` component in order to\n    // preserve native autocorrect behavior, so they shouldn't be handled here.\n    if (Hotkeys.isSplitBlock(event) && !IS_IOS) {\n      return hasVoidParent\n        ? editor.moveToStartOfNextText()\n        : editor.splitBlock()\n    }\n\n    if (Hotkeys.isDeleteBackward(event) && !IS_IOS) {\n      return editor.deleteCharBackward()\n    }\n\n    if (Hotkeys.isDeleteForward(event) && !IS_IOS) {\n      return editor.deleteCharForward()\n    }\n\n    if (Hotkeys.isDeleteLineBackward(event)) {\n      return editor.deleteLineBackward()\n    }\n\n    if (Hotkeys.isDeleteLineForward(event)) {\n      return editor.deleteLineForward()\n    }\n\n    if (Hotkeys.isDeleteWordBackward(event)) {\n      return editor.deleteWordBackward()\n    }\n\n    if (Hotkeys.isDeleteWordForward(event)) {\n      return editor.deleteWordForward()\n    }\n\n    if (Hotkeys.isRedo(event)) {\n      return editor.redo()\n    }\n\n    if (Hotkeys.isUndo(event)) {\n      return editor.undo()\n    }\n\n    // COMPAT: Certain browsers don't handle the selection updates properly. In\n    // Chrome, the selection isn't properly extended. And in Firefox, the\n    // selection isn't properly collapsed. (2017/10/17)\n    if (Hotkeys.isMoveLineBackward(event)) {\n      event.preventDefault()\n      return editor.moveToStartOfBlock()\n    }\n\n    if (Hotkeys.isMoveLineForward(event)) {\n      event.preventDefault()\n      return editor.moveToEndOfBlock()\n    }\n\n    if (Hotkeys.isExtendLineBackward(event)) {\n      event.preventDefault()\n      return editor.moveFocusToStartOfBlock()\n    }\n\n    if (Hotkeys.isExtendLineForward(event)) {\n      event.preventDefault()\n      return editor.moveFocusToEndOfBlock()\n    }\n\n    // COMPAT: If a void node is selected, or a zero-width text node adjacent to\n    // an inline is selected, we need to handle these hotkeys manually because\n    // browsers won't know what to do.\n    if (Hotkeys.isMoveBackward(event)) {\n      event.preventDefault()\n\n      if (!selection.isCollapsed) {\n        return editor.moveToStart()\n      }\n\n      return editor.moveBackward()\n    }\n\n    if (Hotkeys.isMoveForward(event)) {\n      event.preventDefault()\n\n      if (!selection.isCollapsed) {\n        return editor.moveToEnd()\n      }\n\n      return editor.moveForward()\n    }\n\n    if (Hotkeys.isMoveWordBackward(event)) {\n      event.preventDefault()\n      return editor.moveWordBackward()\n    }\n\n    if (Hotkeys.isMoveWordForward(event)) {\n      event.preventDefault()\n      return editor.moveWordForward()\n    }\n\n    if (Hotkeys.isExtendBackward(event)) {\n      const startText = document.getNode(start.path)\n      const [prevEntry] = document.texts({\n        path: start.path,\n        direction: 'backward',\n      })\n\n      let isPrevInVoid = false\n\n      if (prevEntry) {\n        const [, prevPath] = prevEntry\n        isPrevInVoid = document.hasVoidParent(prevPath, editor)\n      }\n\n      if (hasVoidParent || isPrevInVoid || startText.text === '') {\n        event.preventDefault()\n        return editor.moveFocusBackward()\n      }\n    }\n\n    if (Hotkeys.isExtendForward(event)) {\n      const startText = document.getNode(start.path)\n      const [nextEntry] = document.texts({ path: start.path })\n      let isNextInVoid = false\n\n      if (nextEntry) {\n        const [, nextPath] = nextEntry\n        isNextInVoid = document.hasVoidParent(nextPath, editor)\n      }\n\n      if (hasVoidParent || isNextInVoid || startText.text === '') {\n        event.preventDefault()\n        return editor.moveFocusForward()\n      }\n    }\n\n    next()\n  }\n\n  /**\n   * On mouse down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onMouseDown(event, editor, next) {\n    debug('onMouseDown', { event })\n    isMouseDown = true\n    next()\n  }\n\n  /**\n   * On mouse up.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onMouseUp(event, editor, next) {\n    debug('onMouseUp', { event })\n    isMouseDown = false\n    next()\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onPaste(event, editor, next) {\n    debug('onPaste', { event })\n\n    const { value } = editor\n    const transfer = getEventTransfer(event)\n    const { type, fragment, text } = transfer\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment)\n    }\n\n    if (type === 'text' || type === 'html') {\n      if (!text) return next()\n      const { document, selection, startBlock } = value\n      if (editor.isVoid(startBlock)) return next()\n\n      const defaultBlock = startBlock\n      const defaultMarks = document.getInsertMarksAtRange(selection)\n      const frag = Plain.deserialize(text, { defaultBlock, defaultMarks })\n        .document\n      editor.insertFragment(frag)\n    }\n\n    next()\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onSelect(event, editor, next) {\n    debug('onSelect', { event })\n    const window = getWindow(event.target)\n    const domSelection = window.getSelection()\n    const selection = editor.findSelection(domSelection)\n\n    if (selection) {\n      editor.select(selection)\n    } else {\n      editor.blur()\n    }\n\n    // COMPAT: reset the `isMouseDown` state here in case a `mouseup` event\n    // happens outside the editor. This is needed for `onFocus` handling.\n    isMouseDown = false\n\n    next()\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput,\n    onBlur,\n    onClick,\n    onCopy,\n    onCut,\n    onDragEnd,\n    onDragStart,\n    onDrop,\n    onFocus,\n    onInput,\n    onKeyDown,\n    onMouseDown,\n    onMouseUp,\n    onPaste,\n    onSelect,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default AfterPlugin\n","import Debug from 'debug'\nimport Hotkeys from 'slate-hotkeys'\nimport getWindow from 'get-window'\nimport {\n  IS_FIREFOX,\n  IS_IE,\n  IS_IOS,\n  HAS_INPUT_EVENTS_LEVEL_2,\n} from 'slate-dev-environment'\n\nimport DATA_ATTRS from '../../constants/data-attributes'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:before')\n\n/**\n * A plugin that adds the \"before\" browser-specific logic to the editor.\n *\n * @return {Object}\n */\n\nfunction BeforePlugin() {\n  let activeElement = null\n  let compositionCount = 0\n  let isComposing = false\n  let isCopying = false\n  let isDragging = false\n\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    const isSynthetic = !!event.nativeEvent\n    if (editor.readOnly) return\n\n    // COMPAT: If the browser supports Input Events Level 2, we will have\n    // attached a custom handler for the real `beforeinput` events, instead of\n    // allowing React's synthetic polyfill, so we need to ignore synthetics.\n    if (isSynthetic && HAS_INPUT_EVENTS_LEVEL_2) return\n\n    debug('onBeforeInput', { event })\n    next()\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBlur(event, editor, next) {\n    if (isCopying) return\n    if (editor.readOnly) return\n\n    const { relatedTarget, target } = event\n    const window = getWindow(target)\n\n    // COMPAT: If the current `activeElement` is still the previous one, this is\n    // due to the window being blurred when the tab itself becomes unfocused, so\n    // we want to abort early to allow to editor to stay focused when the tab\n    // becomes focused again.\n    if (activeElement === window.document.activeElement) return\n\n    // COMPAT: The `relatedTarget` can be null when the new focus target is not\n    // a \"focusable\" element (eg. a `<div>` without `tabindex` set).\n    if (relatedTarget) {\n      const el = editor.findDOMNode([])\n\n      // COMPAT: The event should be ignored if the focus is returning to the\n      // editor from an embedded editable element (eg. an <input> element inside\n      // a void node).\n      if (relatedTarget === el) return\n\n      // COMPAT: The event should be ignored if the focus is moving from the\n      // editor to inside a void node's spacer element.\n      if (relatedTarget.hasAttribute(DATA_ATTRS.SPACER)) return\n\n      // COMPAT: The event should be ignored if the focus is moving to a non-\n      // editable section of an element that isn't a void node (eg. a list item\n      // of the check list example).\n      const node = editor.findNode(relatedTarget)\n\n      if (el.contains(relatedTarget) && node && !editor.isVoid(node)) {\n        return\n      }\n    }\n\n    debug('onBlur', { event })\n    next()\n  }\n\n  /**\n   * On composition end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCompositionEnd(event, editor, next) {\n    const n = compositionCount\n\n    // The `count` check here ensures that if another composition starts\n    // before the timeout has closed out this one, we will abort unsetting the\n    // `isComposing` flag, since a composition is still in affect.\n    window.requestAnimationFrame(() => {\n      if (compositionCount > n) return\n      isComposing = false\n    })\n\n    debug('onCompositionEnd', { event })\n    next()\n  }\n\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onClick(event, editor, next) {\n    debug('onClick', { event })\n    next()\n  }\n\n  /**\n   * On composition start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCompositionStart(event, editor, next) {\n    isComposing = true\n    compositionCount++\n\n    const { value } = editor\n    const { selection } = value\n\n    if (!selection.isCollapsed) {\n      // https://github.com/ianstormtaylor/slate/issues/1879\n      // When composition starts and the current selection is not collapsed, the\n      // second composition key-down would drop the text wrapping <spans> which\n      // resulted on crash in content.updateSelection after composition ends\n      // (because it cannot find <span> nodes in DOM). This is a workaround that\n      // erases selection as soon as composition starts and preventing <spans>\n      // to be dropped.\n      editor.delete()\n    }\n\n    debug('onCompositionStart', { event })\n    next()\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCopy(event, editor, next) {\n    const window = getWindow(event.target)\n    isCopying = true\n    window.requestAnimationFrame(() => (isCopying = false))\n\n    debug('onCopy', { event })\n    next()\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCut(event, editor, next) {\n    if (editor.readOnly) return\n\n    const window = getWindow(event.target)\n    isCopying = true\n    window.requestAnimationFrame(() => (isCopying = false))\n\n    debug('onCut', { event })\n    next()\n  }\n\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnd(event, editor, next) {\n    isDragging = false\n    debug('onDragEnd', { event })\n    next()\n  }\n\n  /**\n   * On drag enter.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnter(event, editor, next) {\n    debug('onDragEnter', { event })\n    next()\n  }\n\n  /**\n   * On drag exit.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragExit(event, editor, next) {\n    debug('onDragExit', { event })\n    next()\n  }\n\n  /**\n   * On drag leave.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragLeave(event, editor, next) {\n    debug('onDragLeave', { event })\n    next()\n  }\n\n  /**\n   * On drag over.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragOver(event, editor, next) {\n    // If the target is inside a void node, and only in this case,\n    // call `preventDefault` to signal that drops are allowed.\n    // When the target is editable, dropping is already allowed by\n    // default, and calling `preventDefault` hides the cursor.\n    const node = editor.findNode(event.target)\n\n    if (!node || editor.isVoid(node)) {\n      event.preventDefault()\n    }\n\n    // COMPAT: IE won't call onDrop on contentEditables unless the\n    // default dragOver is prevented:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/913982/\n    // (2018/07/11)\n    if (IS_IE) {\n      event.preventDefault()\n    }\n\n    // If a drag is already in progress, don't do this again.\n    if (!isDragging) {\n      isDragging = true\n\n      // COMPAT: IE will raise an `unspecified error` if dropEffect is\n      // set. (2018/07/11)\n      if (!IS_IE) {\n        event.nativeEvent.dataTransfer.dropEffect = 'move'\n      }\n    }\n\n    debug('onDragOver', { event })\n    next()\n  }\n\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragStart(event, editor, next) {\n    isDragging = true\n    debug('onDragStart', { event })\n    next()\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDrop(event, editor, next) {\n    if (editor.readOnly) return\n\n    // Prevent default so the DOM's value isn't corrupted.\n    event.preventDefault()\n\n    debug('onDrop', { event })\n    next()\n  }\n\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onFocus(event, editor, next) {\n    if (isCopying) return\n    if (editor.readOnly) return\n\n    const el = editor.findDOMNode([])\n\n    // Save the new `activeElement`.\n    const window = getWindow(event.target)\n    activeElement = window.document.activeElement\n\n    // COMPAT: If the editor has nested editable elements, the focus can go to\n    // those elements. In Firefox, this must be prevented because it results in\n    // issues with keyboard navigation. (2017/03/30)\n    if (IS_FIREFOX && event.target !== el) {\n      el.focus()\n      return\n    }\n\n    debug('onFocus', { event })\n    next()\n  }\n\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onInput(event, editor, next) {\n    if (isComposing) return\n    if (editor.value.selection.isBlurred) return\n    debug('onInput', { event })\n    next()\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onKeyDown(event, editor, next) {\n    if (editor.readOnly) return\n\n    // When composing, we need to prevent all hotkeys from executing while\n    // typing. However, certain characters also move the selection before\n    // we're able to handle it, so prevent their default behavior.\n    if (isComposing) {\n      if (Hotkeys.isCompose(event)) event.preventDefault()\n      return\n    }\n\n    // Certain hotkeys have native editing behaviors in `contenteditable`\n    // elements which will editor the DOM and cause our value to be out of sync,\n    // so they need to always be prevented.\n    if (\n      !IS_IOS &&\n      (Hotkeys.isBold(event) ||\n        Hotkeys.isDeleteBackward(event) ||\n        Hotkeys.isDeleteForward(event) ||\n        Hotkeys.isDeleteLineBackward(event) ||\n        Hotkeys.isDeleteLineForward(event) ||\n        Hotkeys.isDeleteWordBackward(event) ||\n        Hotkeys.isDeleteWordForward(event) ||\n        Hotkeys.isItalic(event) ||\n        Hotkeys.isRedo(event) ||\n        Hotkeys.isSplitBlock(event) ||\n        Hotkeys.isTransposeCharacter(event) ||\n        Hotkeys.isUndo(event))\n    ) {\n      event.preventDefault()\n    }\n\n    debug('onKeyDown', { event })\n    next()\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onPaste(event, editor, next) {\n    if (editor.readOnly) return\n\n    // Prevent defaults so the DOM state isn't corrupted.\n    event.preventDefault()\n\n    debug('onPaste', { event })\n    next()\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onSelect(event, editor, next) {\n    if (isCopying) return\n    if (isComposing) return\n\n    if (editor.readOnly) return\n\n    // Save the new `activeElement`.\n    const window = getWindow(event.target)\n    activeElement = window.document.activeElement\n\n    debug('onSelect', { event })\n    next()\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput,\n    onBlur,\n    onClick,\n    onCompositionEnd,\n    onCompositionStart,\n    onCopy,\n    onCut,\n    onDragEnd,\n    onDragEnter,\n    onDragExit,\n    onDragLeave,\n    onDragOver,\n    onDragStart,\n    onDrop,\n    onFocus,\n    onInput,\n    onKeyDown,\n    onPaste,\n    onSelect,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default BeforePlugin\n","import { IS_ANDROID } from 'slate-dev-environment'\nimport AndroidPlugin from '../android'\nimport AfterPlugin from './after'\nimport BeforePlugin from './before'\n\n/**\n * A plugin that adds the browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction DOMPlugin(options = {}) {\n  const { plugins = [] } = options\n  const beforePlugin = BeforePlugin()\n  const afterPlugin = AfterPlugin()\n\n  // COMPAT: Add Android specific handling separately before it gets to the\n  // other plugins because it is specific (other browser don't need it) and\n  // finicky (it has to come before other plugins to work).\n  const beforeBeforePlugins = IS_ANDROID ? [AndroidPlugin()] : []\n\n  return [...beforeBeforePlugins, beforePlugin, ...plugins, afterPlugin]\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default DOMPlugin\n","function RestoreDOMPlugin() {\n  /**\n   * Makes sure that on the next Content `render` the DOM is restored.\n   * This gets us around issues where the DOM is in a different state than\n   * React's virtual DOM and would crash.\n   *\n   * @param {Editor} editor\n   */\n\n  function restoreDOM(editor) {\n    editor.setState({ contentKey: editor.state.contentKey + 1 })\n  }\n\n  return {\n    commands: {\n      restoreDOM,\n    },\n  }\n}\n\nexport default RestoreDOMPlugin\n","/**\n * Takes a React Synthetic Event or a DOM Event and turns it into a String that\n * is easy to log. It's succinct and keeps info to a bare minimum.\n *\n * @param {Event} event\n */\n\nexport default function stringifyEvent(event) {\n  const e = event.nativeEvent || event\n\n  switch (e.type) {\n    case 'keydown':\n      return `${e.type} ${JSON.stringify(e.key)}`\n    case 'input':\n    case 'beforeinput':\n    case 'textInput':\n      return `${e.type}:${e.inputType} ${JSON.stringify(e.data)}`\n    default:\n      return e.type\n  }\n}\n","import Debug from 'debug'\nimport EVENT_HANDLERS from '../../constants/event-handlers'\nimport stringifyEvent from './stringify-event'\n\n/**\n * Debug events function.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:events')\n\n/**\n * A plugin that sends short easy to digest debug info about each event to\n * browser.\n *\n * @return {Object}\n */\n\nfunction DebugEventsPlugin() {\n  /**\n   * Plugin Object\n   *\n   * @type {Object}\n   */\n\n  const plugin = {}\n\n  for (const eventName of EVENT_HANDLERS) {\n    plugin[eventName] = function(event, editor, next) {\n      const s = stringifyEvent(event)\n      debug(s)\n      next()\n    }\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return plugin\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default DebugEventsPlugin\n","import Debug from 'debug'\nimport EVENT_HANDLERS from '../../constants/event-handlers'\nimport stringifyEvent from './stringify-event'\n\n/**\n * Constants\n */\n\nconst INTERVAL = 2000\n\n/**\n * Debug events function.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:batch-events')\n\n/**\n * A plugin that sends short easy to digest debug info about each event to\n * browser.\n *\n * @return {Object}\n */\n\nfunction DebugBatchEventsPlugin() {\n  /**\n   * When the batch started\n   *\n   * @type {Date}\n   */\n\n  let startDate = null\n\n  /**\n   * The timeoutId used to cancel the timeout\n   *\n   * @type {Any}\n   */\n\n  let timeoutId = null\n\n  /**\n   * An array of events not yet dumped with `debug`\n   *\n   * @type {Array}\n   */\n\n  const events = []\n\n  /**\n   * Send all events to debug\n   *\n   * Note: Formatted so it can easily be cut and pasted as text for analysis or\n   * documentation.\n   */\n\n  function dumpEvents() {\n    debug(`\\n${events.join('\\n')}`)\n    events.length = 0\n  }\n\n  /**\n   * Push an event on to the Array of events for debugging in a batch\n   *\n   * @param {Event} event\n   */\n\n  function pushEvent(event) {\n    if (events.length === 0) {\n      startDate = new Date()\n    }\n\n    const s = stringifyEvent(event)\n    const now = new Date()\n    events.push(`- ${now - startDate} - ${s}`)\n    clearTimeout(timeoutId)\n    timeoutId = setTimeout(dumpEvents, INTERVAL)\n  }\n\n  /**\n   * Plugin Object\n   *\n   * @type {Object}\n   */\n\n  const plugin = {}\n\n  for (const eventName of EVENT_HANDLERS) {\n    plugin[eventName] = function(event, editor, next) {\n      pushEvent(event)\n      next()\n    }\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return plugin\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default DebugBatchEventsPlugin\n","import Debug from 'debug'\nimport PlaceholderPlugin from 'slate-react-placeholder'\n\nimport EditorPropsPlugin from './editor-props'\nimport RenderingPlugin from './rendering'\nimport CommandsPlugin from './commands'\nimport QueriesPlugin from './queries'\nimport DOMPlugin from '../dom'\nimport RestoreDOMPlugin from './restore-dom'\nimport DebugEventsPlugin from '../debug/debug-events'\nimport DebugBatchEventsPlugin from '../debug/debug-batch-events'\n\n/**\n * A plugin that adds the React-specific rendering logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction ReactPlugin(options = {}) {\n  const { placeholder = '', plugins = [] } = options\n  const debugEventsPlugin = Debug.enabled('slate:events')\n    ? DebugEventsPlugin(options)\n    : null\n  const debugBatchEventsPlugin = Debug.enabled('slate:batch-events')\n    ? DebugBatchEventsPlugin(options)\n    : null\n  const renderingPlugin = RenderingPlugin(options)\n  const commandsPlugin = CommandsPlugin(options)\n  const queriesPlugin = QueriesPlugin(options)\n  const editorPropsPlugin = EditorPropsPlugin(options)\n  const domPlugin = DOMPlugin({\n    plugins: [editorPropsPlugin, ...plugins],\n  })\n  const restoreDomPlugin = RestoreDOMPlugin()\n  const placeholderPlugin = PlaceholderPlugin({\n    placeholder,\n    when: (editor, node) =>\n      node.object === 'document' &&\n      node.text === '' &&\n      node.nodes.size === 1 &&\n      Array.from(node.texts()).length === 1,\n  })\n\n  return [\n    debugEventsPlugin,\n    debugBatchEventsPlugin,\n    domPlugin,\n    restoreDomPlugin,\n    placeholderPlugin,\n    renderingPlugin,\n    commandsPlugin,\n    queriesPlugin,\n  ]\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default ReactPlugin\n","import Debug from 'debug'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\nimport invariant from 'tiny-invariant'\nimport memoizeOne from 'memoize-one'\nimport warning from 'tiny-warning'\nimport { Editor as Controller } from 'slate'\n\nimport EVENT_HANDLERS from '../constants/event-handlers'\nimport Content from './content'\nimport ReactPlugin from '../plugins/react'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:editor')\n\n/**\n * Editor.\n *\n * @type {Component}\n */\n\nclass Editor extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    autoCorrect: Types.bool,\n    autoFocus: Types.bool,\n    className: Types.string,\n    defaultValue: SlateTypes.value,\n    id: Types.string,\n    onChange: Types.func,\n    options: Types.object,\n    placeholder: Types.any,\n    plugins: Types.array,\n    readOnly: Types.bool,\n    role: Types.string,\n    schema: Types.object,\n    spellCheck: Types.bool,\n    style: Types.object,\n    tabIndex: Types.number,\n    value: SlateTypes.value,\n    ...EVENT_HANDLERS.reduce((obj, handler) => {\n      obj[handler] = Types.func\n      return obj\n    }, {}),\n  }\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  static defaultProps = {\n    autoFocus: false,\n    autoCorrect: true,\n    onChange: () => {},\n    options: {},\n    placeholder: '',\n    plugins: [],\n    readOnly: false,\n    schema: {},\n    spellCheck: true,\n  }\n\n  /**\n   * Initial state.\n   *\n   * @type {Object}\n   */\n\n  state = { value: this.props.defaultValue, contentKey: 0 }\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  tmp = {\n    mounted: false,\n    change: null,\n    resolves: 0,\n    updates: 0,\n    contentRef: React.createRef(),\n  }\n\n  /**\n   * When the component first mounts, flush a queued change if one exists.\n   */\n\n  componentDidMount() {\n    this.tmp.mounted = true\n    this.tmp.updates++\n\n    if (this.props.autoFocus) {\n      this.focus()\n    }\n\n    if (this.tmp.change) {\n      this.handleChange(this.tmp.change)\n      this.tmp.change = null\n    }\n  }\n\n  /**\n   * When the component updates, flush a queued change if one exists.\n   */\n\n  componentDidUpdate() {\n    this.tmp.updates++\n\n    if (this.tmp.change) {\n      this.handleChange(this.tmp.change)\n      this.tmp.change = null\n    }\n  }\n\n  /**\n   * When the component unmounts, make sure async commands don't trigger react updates.\n   */\n\n  componentWillUnmount() {\n    this.tmp.mounted = false\n  }\n\n  /**\n   * Render the editor.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    debug('render', this)\n\n    // Re-resolve the controller if needed based on memoized props.\n    const { commands, placeholder, plugins, queries, schema } = this.props\n    this.resolveController(plugins, schema, commands, queries, placeholder)\n\n    // Set the current props on the controller.\n    const { options, readOnly, value: valueFromProps } = this.props\n    const { value: valueFromState } = this.state\n    const value = valueFromProps || valueFromState\n    const { contentKey } = this.state\n    this.controller.setReadOnly(readOnly)\n    this.controller.setValue(value, options)\n\n    const {\n      autoCorrect,\n      className,\n      id,\n      role,\n      spellCheck,\n      tabIndex,\n      style,\n      tagName,\n    } = this.props\n\n    const children = (\n      <Content\n        ref={this.tmp.contentRef}\n        autoCorrect={autoCorrect}\n        className={className}\n        contentKey={contentKey}\n        editor={this}\n        id={id}\n        onEvent={(handler, event) => this.run(handler, event)}\n        readOnly={readOnly}\n        role={role}\n        spellCheck={spellCheck}\n        style={style}\n        tabIndex={tabIndex}\n        tagName={tagName}\n      />\n    )\n\n    // Render the editor's children with the controller.\n    const element = this.controller.run('renderEditor', {\n      ...this.props,\n      editor: this,\n      children,\n    })\n\n    return element\n  }\n\n  /**\n   * Resolve an editor controller from the passed-in props. This method takes\n   * all of the props as individual arguments to be able to properly memoize\n   * against anything that could change and invalidate the old editor.\n   *\n   * @param {Array} plugins\n   * @param {Object} schema\n   * @param {Object} commands\n   * @param {Object} queries\n   * @param {String} placeholder\n   * @return {Editor}\n   */\n\n  resolveController = memoizeOne(\n    (plugins = [], schema, commands, queries, placeholder) => {\n      // If we've resolved a few times already, and it's exactly in line with\n      // the updates, then warn the user that they may be doing something wrong.\n      warning(\n        this.tmp.resolves < 5 || this.tmp.resolves !== this.tmp.updates,\n        'A Slate <Editor> component is re-resolving the `plugins`, `schema`, `commands`, `queries` or `placeholder` prop on each update, which leads to poor performance. This is often due to passing in a new references for these props with each render by declaring them inline in your render function. Do not do this! Declare them outside your render function, or memoize them instead.'\n      )\n\n      this.tmp.resolves++\n      const react = ReactPlugin({\n        ...this.props,\n        value: this.props.value || this.state.value,\n      })\n\n      const onChange = change => {\n        if (this.tmp.mounted) {\n          this.handleChange(change)\n        } else {\n          this.tmp.change = change\n        }\n      }\n\n      this.controller = new Controller(\n        { plugins: [react], onChange },\n        { controller: this, construct: false }\n      )\n\n      this.controller.run('onConstruct')\n    }\n  )\n\n  handleChange(change) {\n    const { onChange } = this.props\n    const { value } = this.state\n\n    if (value) {\n      // Syncing value inside this component since parent does not want control of it (defaultValue was used)\n      this.setState({ value: change.value })\n    }\n\n    onChange(change)\n  }\n\n  /**\n   * Mimic the API of the `Editor` controller, so that this component instance\n   * can be passed in its place to plugins.\n   */\n\n  get operations() {\n    return this.controller.operations\n  }\n\n  get readOnly() {\n    return this.controller.readOnly\n  }\n\n  get value() {\n    return this.controller.value\n  }\n\n  applyOperation(...args) {\n    return this.controller.applyOperation(...args)\n  }\n\n  command(...args) {\n    return this.controller.command(...args)\n  }\n\n  hasCommand(...args) {\n    return this.controller.hasCommand(...args)\n  }\n\n  hasQuery(...args) {\n    return this.controller.hasQuery(...args)\n  }\n\n  normalize(...args) {\n    return this.controller.normalize(...args)\n  }\n\n  query(...args) {\n    return this.controller.query(...args)\n  }\n\n  registerCommand(...args) {\n    return this.controller.registerCommand(...args)\n  }\n\n  registerQuery(...args) {\n    return this.controller.registerQuery(...args)\n  }\n\n  run(...args) {\n    return this.controller.run(...args)\n  }\n\n  withoutNormalizing(...args) {\n    return this.controller.withoutNormalizing(...args)\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  get editor() {\n    return this.controller.editor\n  }\n\n  get schema() {\n    invariant(\n      false,\n      'As of Slate 0.42, the `editor.schema` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.'\n    )\n  }\n\n  get stack() {\n    invariant(\n      false,\n      'As of Slate 0.42, the `editor.stack` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.'\n    )\n  }\n\n  call(...args) {\n    return this.controller.call(...args)\n  }\n\n  change(...args) {\n    return this.controller.change(...args)\n  }\n\n  onChange(...args) {\n    return this.controller.onChange(...args)\n  }\n\n  applyOperations(...args) {\n    return this.controller.applyOperations(...args)\n  }\n\n  setOperationFlag(...args) {\n    return this.controller.setOperationFlag(...args)\n  }\n\n  getFlag(...args) {\n    return this.controller.getFlag(...args)\n  }\n\n  unsetOperationFlag(...args) {\n    return this.controller.unsetOperationFlag(...args)\n  }\n\n  withoutNormalization(...args) {\n    return this.controller.withoutNormalization(...args)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Editor\n","import findDOMNode from './find-dom-node'\nimport warning from 'tiny-warning'\n\nimport DATA_ATTRS from '../constants/data-attributes'\nimport SELECTORS from '../constants/selectors'\n\n/**\n * Find a native DOM selection point from a Slate `point`.\n *\n * @param {Point} point\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\nfunction findDOMPoint(point, win = window) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findDOMPoint(point)` helper is deprecated in favor of `editor.findDOMPoint(point)`.'\n  )\n\n  const el = findDOMNode(point.key, win)\n  let start = 0\n\n  // For each leaf, we need to isolate its content, which means filtering to its\n  // direct text and zero-width spans. (We have to filter out any other siblings\n  // that may have been rendered alongside them.)\n  const texts = Array.from(\n    el.querySelectorAll(`${SELECTORS.STRING}, ${SELECTORS.ZERO_WIDTH}`)\n  )\n\n  for (const text of texts) {\n    const node = text.childNodes[0]\n    const domLength = node.textContent.length\n    let slateLength = domLength\n\n    if (text.hasAttribute(DATA_ATTRS.LENGTH)) {\n      slateLength = parseInt(text.getAttribute(DATA_ATTRS.LENGTH), 10)\n    }\n\n    const end = start + slateLength\n\n    if (point.offset <= end) {\n      const offset = Math.min(domLength, Math.max(0, point.offset - start))\n      return { node, offset }\n    }\n\n    start = end\n  }\n\n  return null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMPoint\n","import findDOMPoint from './find-dom-point'\nimport warning from 'tiny-warning'\n\n/**\n * Find a native DOM range Slate `range`.\n *\n * @param {Range} range\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\nfunction findDOMRange(range, win = window) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findDOMRange(range)` helper is deprecated in favor of `editor.findDOMRange(range)`.'\n  )\n\n  const { anchor, focus, isBackward, isCollapsed } = range\n  const domAnchor = findDOMPoint(anchor, win)\n  const domFocus = isCollapsed ? domAnchor : findDOMPoint(focus, win)\n\n  if (!domAnchor || !domFocus) return null\n\n  const r = win.document.createRange()\n  const start = isBackward ? domFocus : domAnchor\n  const end = isBackward ? domAnchor : domFocus\n  r.setStart(start.node, start.offset)\n  r.setEnd(end.node, end.offset)\n  return r\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMRange\n","import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Value } from 'slate'\n\nimport DATA_ATTRS from '../constants/data-attributes'\nimport SELECTORS from '../constants/selectors'\n\n/**\n * Find a Slate node from a DOM `element`.\n *\n * @param {Element} element\n * @param {Editor} editor\n * @return {Node|Null}\n */\n\nfunction findNode(element, editor) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findNode(element)` helper is deprecated in favor of `editor.findNode(element)`.'\n  )\n\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.'\n  )\n\n  const closest = element.closest(SELECTORS.KEY)\n  if (!closest) return null\n\n  const key = closest.getAttribute(DATA_ATTRS.KEY)\n  if (!key) return null\n\n  const { value } = editor\n  const { document } = value\n  const node = document.getNode(key)\n  return node || null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findNode\n","import findNode from './find-node'\nimport warning from 'tiny-warning'\n\n/**\n * Find a Slate path from a DOM `element`.\n *\n * @param {Element} element\n * @param {Editor} editor\n * @return {List|Null}\n */\n\nfunction findPath(element, editor) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findPath(element)` helper is deprecated in favor of `editor.findPath(element)`.'\n  )\n\n  const node = findNode(element, editor)\n\n  if (!node) {\n    return null\n  }\n\n  const { value } = editor\n  const { document } = value\n  const path = document.getPath(node)\n  return path\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findPath\n","import getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Value } from 'slate'\n\nimport findPath from './find-node'\nimport findRange from './find-range'\n\n/**\n * Get the target range from a DOM `event`.\n *\n * @param {Event} event\n * @param {Editor} editor\n * @return {Range}\n */\n\nfunction getEventRange(event, editor) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `getEventRange(event, editor)` helper is deprecated in favor of `editor.findEventRange(event)`.'\n  )\n\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.'\n  )\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const { clientX: x, clientY: y, target } = event\n  if (x == null || y == null) return null\n\n  const { value } = editor\n  const { document } = value\n  const path = findPath(event.target, editor)\n  if (!path) return null\n\n  const node = document.getNode(path)\n\n  // If the drop target is inside a void node, move it into either the next or\n  // previous node, depending on which side the `x` and `y` coordinates are\n  // closest to.\n  if (editor.isVoid(node)) {\n    const rect = target.getBoundingClientRect()\n    const isPrevious =\n      node.object === 'inline'\n        ? x - rect.left < rect.left + rect.width - x\n        : y - rect.top < rect.top + rect.height - y\n\n    const range = document.createRange()\n    const iterable = isPrevious ? 'previousTexts' : 'nextTexts'\n    const move = isPrevious ? 'moveToEndOfNode' : 'moveToStartOfNode'\n    const entry = document[iterable](path)\n\n    if (entry) {\n      const [n] = entry\n      return range[move](n)\n    }\n\n    return null\n  }\n\n  // Else resolve a range from the caret position where the drop occured.\n  const window = getWindow(target)\n  let native\n\n  // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n  if (window.document.caretRangeFromPoint) {\n    native = window.document.caretRangeFromPoint(x, y)\n  } else if (window.document.caretPositionFromPoint) {\n    const position = window.document.caretPositionFromPoint(x, y)\n    native = window.document.createRange()\n    native.setStart(position.offsetNode, position.offset)\n    native.setEnd(position.offsetNode, position.offset)\n  } else if (window.document.body.createTextRange) {\n    // COMPAT: In IE, `caretRangeFromPoint` and\n    // `caretPositionFromPoint` don't exist. (2018/07/11)\n    native = window.document.body.createTextRange()\n\n    try {\n      native.moveToPoint(x, y)\n    } catch (error) {\n      // IE11 will raise an `unspecified error` if `moveToPoint` is\n      // called during a dropEvent.\n      return null\n    }\n  }\n\n  // Resolve a Slate range from the DOM range.\n  const range = findRange(native, editor)\n  if (!range) return null\n\n  return range\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getEventRange\n","import Editor from './components/editor'\nimport cloneFragment from './utils/clone-fragment'\nimport findDOMNode from './utils/find-dom-node'\nimport findDOMPoint from './utils/find-dom-point'\nimport findDOMRange from './utils/find-dom-range'\nimport findNode from './utils/find-node'\nimport findPath from './utils/find-path'\nimport findPoint from './utils/find-point'\nimport findRange from './utils/find-range'\nimport getEventRange from './utils/get-event-range'\nimport getEventTransfer from './utils/get-event-transfer'\nimport setEventTransfer from './utils/set-event-transfer'\nimport ReactPlugin from './plugins/react'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport {\n  Editor,\n  cloneFragment,\n  findDOMNode,\n  findDOMPoint,\n  findDOMRange,\n  findNode,\n  findPath,\n  findPoint,\n  findRange,\n  getEventRange,\n  getEventTransfer,\n  setEventTransfer,\n  ReactPlugin,\n}\n\nexport default {\n  Editor,\n  cloneFragment,\n  findDOMNode,\n  findDOMPoint,\n  findDOMRange,\n  findNode,\n  findPath,\n  findPoint,\n  findRange,\n  getEventRange,\n  getEventTransfer,\n  setEventTransfer,\n  ReactPlugin,\n}\n"],"names":["EVENT_HANDLERS","DATA_ATTRS","OBJECT","EDITOR","KEY","LEAF","STRING","VOID","ZERO_WIDTH","PARSER","parse","string","matches","exec","Error","original","key","index","parseInt","stringify","object","TextString","text","isTrailing","ZeroWidthString","length","isLineBreak","LENGTH","Leaf","marks","props","annotations","decorations","node","offset","editor","parent","block","leaves","offsetKey","OffsetKey","children","query","nodes","last","lastText","getLastText","lastChar","charAt","isLastText","isLastLeaf","size","renderProps","mark","ret","run","decoration","annotation","attrs","OFFSET_KEY","propTypes","ImmutableTypes","list","isRequired","SlateTypes","Types","number","MemoizedLeaf","React","memo","prev","next","equals","Text","forwardRef","ref","style","getLeaves","at","map","leaf","MemoizedText","debug","Debug","Void","readOnly","Tag","spacerAttrs","SPACER","spacer","renderText","content","Component","any","bool","message","args","type","id","textRef","child","getFirstText","Node","nextProps","shouldUpdate","n","p","selection","newDecorations","getDecorations","toArray","i","sel","getRelativeRange","decs","d","filter","concat","anns","a","tmp","nodeRefs","attributes","isLeafBlock","direction","getTextDirection","dir","render","element","isFocused","isVoid","createRef","range","isUnset","get","start","end","startPath","path","endPath","startIndex","first","endIndex","setPath","rest","moveTo","PathUtils","create","texts","firstPath","lastNode","lastPath","setStart","setEnd","OVERFLOWS","IS_IOS_11","IS_IOS","window","navigator","userAgent","match","findScrollContainer","el","parentNode","scroller","getComputedStyle","overflowY","includes","document","body","scrollToSelection","anchorNode","getWindow","isWindow","documentElement","backward","isBackward","getRangeAt","cloneRange","collapse","cursorRect","getBoundingClientRect","IS_SAFARI","collapsed","top","height","startOffset","endContainer","startContainer","getClientRects","width","yOffset","xOffset","scrollerTop","scrollerLeft","scrollerBordersY","scrollerBordersX","scrollerPaddingTop","scrollerPaddingBottom","scrollerPaddingLeft","scrollerPaddingRight","innerWidth","innerHeight","pageYOffset","pageXOffset","offsetWidth","offsetHeight","scrollTop","scrollLeft","borderTopWidth","borderBottomWidth","borderLeftWidth","borderRightWidth","paddingTop","paddingBottom","paddingLeft","paddingRight","scrollerRect","left","cursorTop","cursorLeft","x","y","scrollTo","removeAllRanges","domSelection","IS_IE","createTextRange","select","FIREFOX_NODE_TYPE_ACCESS_ERROR","update","Content","handlers","reduce","obj","handler","onEvent","event","updateSelection","value","current","native","getSelection","activeElement","enabled","toJSON","rangeCount","updated","isBlurred","blur","isInEditor","focus","preventScroll","isSet","findDOMRange","endOffset","isUpdatingSelection","setBaseAndExtent","addRange","IS_FIREFOX","target","nodeType","err","test","isContentEditable","closest","SELECTORS","onNativeSelectionChange","throttle","error","info","setState","addEventListener","HAS_INPUT_EVENTS_LEVEL_2","onBeforeInput","removeEventListener","IS_ANDROID","findRange","toRange","className","tabIndex","role","tagName","spellCheck","Container","WebkitUserModify","data","contentKey","autoCorrect","List","nodeRef","defaultProps","PROPS","EditorPropsPlugin","options","plugin","prop","Rendering","position","CommandsPlugin","reconcileNode","getPath","domElement","findDOMNode","getClosestBlock","domText","textContent","isLastNode","slice","entire","moveAnchorTo","moveFocusTo","resolveRange","insertTextAtRange","reconcileDOMNode","domNode","parentElement","findNode","QueriesPlugin","contentRef","search","instance","findDOMPoint","point","Array","from","querySelectorAll","childNodes","domLength","slateLength","hasAttribute","getAttribute","Math","min","max","anchor","isCollapsed","domAnchor","domFocus","r","createRange","findPath","getNode","findEventRange","nativeEvent","clientX","clientY","rect","isPrevious","move","entry","caretRangeFromPoint","caretPositionFromPoint","offsetNode","moveToPoint","nodeElement","keys","Object","findPoint","nativeNode","nativeOffset","normalizeNodeAndOffset","nearestNode","nearestOffset","leafNode","textNode","TEXT","contents","cloneContents","zeroWidths","forEach","removeChild","voidNode","querySelector","createPoint","domRange","Range","StaticRange","anchorOffset","focusNode","focusOffset","findSelection","anchorText","focusText","anchorInline","getClosestInline","focusInline","focusBlock","anchorBlock","setFocus","setOffset","depth","getDepth","relativePath","drop","nextPath","absolutePath","createSelection","setIsFocused","set","isLast","getEditableChild","triedForward","triedBackward","fixSelectionInZeroWidthBlock","dataset","isZeroWidth","slateZeroWidth","Value","isValue","rangeNode","hasDescendant","getSelectionFromDOM","isInputDataEnter","charCode","charCodeAt","isInputDataLastChar","chars","isArray","isTextNode","TEXT_NODE","getElementSnapshot","snapshot","childNode","getSnapshot","elements","lastElement","nextElementSibling","applyElementSnapshot","childSnapshot","appendChild","snapLength","dups","Set","delete","dup","applySnapshot","insertBefore","prevElement","ElementSnapshot","selector","win","DomSnapshot","before","subrootEl","previousElementSibling","unshift","apply","noop","Executor","fn","__call__","preventFurtherCalls","resume","cancel","ms","mode","timeoutId","setTimeout","callbackId","requestAnimationFrame","clearTimeout","cancelAnimationFrame","onCancel","__setTimeout__","timeout","reconcile","ANDROID_API_VERSION","NONE","COMPOSING","AndroidPlugin","status","compositionEndSnapshot","reconciler","keyDownSnapshot","deleter","preventNextBeforeInput","compositionEndAction","clear","isNative","pick","preventDefault","inputType","getSelectionFromDom","splitBlock","isEnter","onCompositionEnd","add","onCompositionStart","onCompositionUpdate","onInput","deleteBackward","onKeyDown","onSelect","isNode","FRAGMENT","TRANSFER_TYPES","HTML","cloneFragment","callback","undefined","fragment","startVoid","getClosestVoid","endVoid","encoded","Base64","serializeNode","attach","trim","setEndAfter","firstChild","call","isNewline","zw","span","createElement","whiteSpace","setAttribute","valFromSelection","plainText","Plain","serialize","div","clipboardData","setData","innerHTML","editorEl","selectAllChildren","NODE","RICH","FRAGMENT_MATCHER","getEventTransfer","transfer","dataTransfer","getType","html","rich","files","indexOf","full","embeddedTypes","getEmbeddedTypes","deserializeNode","items","item","kind","getAsFile","exists","getTransferType","prefix","substring","JSON","types","getData","setEventTransfer","mime","toUpperCase","e","AfterPlugin","isDraggingInternally","isMouseDown","isSynthetic","insertText","getTargetRanges","targetRange","deleteAtRange","deleteWordBackwardAtRange","deleteWordForwardAtRange","deleteLineBackwardAtRange","deleteLineForwardAtRange","hasVoidParent","moveToStartOfNextText","splitBlockAtRange","onBlur","onClick","ancestors","getAncestors","some","moveToEndOfNode","onCopy","onCut","voidPath","removeNodeByKey","onDragEnd","onDragStart","selectionIncludesNode","blocks","moveToRangeOfNode","onDrop","moveForward","nxt","moveToStartOfNode","split","line","insertFragment","dispatchEvent","MouseEvent","onFocus","IS_EDGE","deselect","Hotkeys","isSplitBlock","isDeleteBackward","deleteCharBackward","isDeleteForward","deleteCharForward","isDeleteLineBackward","deleteLineBackward","isDeleteLineForward","deleteLineForward","isDeleteWordBackward","deleteWordBackward","isDeleteWordForward","deleteWordForward","isRedo","redo","isUndo","undo","isMoveLineBackward","moveToStartOfBlock","isMoveLineForward","moveToEndOfBlock","isExtendLineBackward","moveFocusToStartOfBlock","isExtendLineForward","moveFocusToEndOfBlock","isMoveBackward","moveToStart","moveBackward","isMoveForward","moveToEnd","isMoveWordBackward","moveWordBackward","isMoveWordForward","moveWordForward","isExtendBackward","startText","prevEntry","isPrevInVoid","prevPath","moveFocusBackward","isExtendForward","nextEntry","isNextInVoid","moveFocusForward","onMouseDown","onMouseUp","onPaste","startBlock","defaultBlock","defaultMarks","getInsertMarksAtRange","frag","deserialize","BeforePlugin","compositionCount","isComposing","isCopying","isDragging","relatedTarget","contains","onDragEnter","onDragExit","onDragLeave","onDragOver","dropEffect","isCompose","isBold","isItalic","isTransposeCharacter","DOMPlugin","plugins","beforePlugin","afterPlugin","beforeBeforePlugins","RestoreDOMPlugin","restoreDOM","state","stringifyEvent","DebugEventsPlugin","eventName","s","INTERVAL","DebugBatchEventsPlugin","startDate","events","dumpEvents","join","pushEvent","Date","now","push","ReactPlugin","placeholder","debugEventsPlugin","debugBatchEventsPlugin","renderingPlugin","RenderingPlugin","commandsPlugin","queriesPlugin","editorPropsPlugin","domPlugin","restoreDomPlugin","placeholderPlugin","PlaceholderPlugin","Editor","defaultValue","resolveController","memoizeOne","resolves","updates","react","onChange","mounted","handleChange","change","controller","Controller","construct","autoFocus","commands","queries","schema","valueFromProps","valueFromState","setReadOnly","setValue","applyOperation","command","hasCommand","hasQuery","normalize","registerCommand","registerQuery","withoutNormalizing","applyOperations","setOperationFlag","getFlag","unsetOperationFlag","withoutNormalization","operations","func","array","getEventRange","iterable"],"mappings":"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"}